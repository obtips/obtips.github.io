<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>237号房间</title><link>https://cell.237927.xyz</link><description>希望，或许是最好的东西。</description><copyright>237号房间</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://cell.237927.xyz/avatar.svg</url><title>avatar</title><link>https://cell.237927.xyz</link></image><lastBuildDate>Wed, 31 Jul 2024 06:12:26 +0000</lastBuildDate><managingEditor>237号房间</managingEditor><ttl>60</ttl><webMaster>237号房间</webMaster><item><title>实用工具合集</title><link>https://cell.237927.xyz/post/shi-yong-gong-ju-he-ji.html</link><description>---&#13;
## 小工具&#13;
[高比率视频压缩](https://tools.rotato.app/compress)&#13;
---。</description><guid isPermaLink="true">https://cell.237927.xyz/post/shi-yong-gong-ju-he-ji.html</guid><pubDate>Wed, 31 Jul 2024 06:05:53 +0000</pubDate></item><item><title>[Swift 官方教程]17 错误处理</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D17%20-cuo-wu-chu-li.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
## [表示和抛出错误 (Representing and Throwing Errors)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/errorhandling#Representing-and-Throwing-Errors)&#13;
&#13;
使用符合 `Error` 协议的类型值来表示错误, 而枚举很适合:&#13;
```swift&#13;
enum VendingMachineError: Error {&#13;
    case invalidSelection&#13;
    case insufficientFunds(coinsNeeded: Int)&#13;
    case outOfStock&#13;
}&#13;
```&#13;
&#13;
抛出错误:&#13;
```swift&#13;
throw VendingMachineError.insufficientFunds(coinsNeeded: 5)&#13;
```&#13;
## [处理错误 (Handling Errors)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/errorhandling#Handling-Errors)&#13;
### [传播错误 (Propagating Errors Using Throwing Functions)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/errorhandling/#Propagating-Errors-Using-Throwing-Functions)&#13;
&#13;
使用 `throw` 标记一个可抛出错误的函数, 方法或初始化器:&#13;
```swift&#13;
func canThrowErrors() throws -&gt; String&#13;
```&#13;
如果没有该标记, 则必须在函数内部处理该错误.&#13;
&#13;
函数` vend` 会传播错误:&#13;
```swift&#13;
struct Item {&#13;
    var price: Int&#13;
    var count: Int&#13;
}&#13;
&#13;
class VendingMachine {&#13;
    var inventory = [&#13;
        'Candy Bar': Item(price: 12, count: 7),&#13;
        'Chips': Item(price: 10, count: 4),&#13;
        'Pretzels': Item(price: 7, count: 11)&#13;
    ]&#13;
    var coinsDeposited = 0&#13;
&#13;
    func vend(itemNamed name: String) throws {&#13;
        guard let item = inventory[name] else {&#13;
            throw VendingMachineError.invalidSelection&#13;
        }&#13;
&#13;
        guard item.count &gt; 0 else {&#13;
            throw VendingMachineError.outOfStock&#13;
        }&#13;
&#13;
        guard item.price &lt;= coinsDeposited else {&#13;
            throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited)&#13;
        }&#13;
&#13;
        coinsDeposited -= item.price&#13;
&#13;
        var newItem = item&#13;
        newItem.count -= 1&#13;
        inventory[name] = newItem&#13;
&#13;
        print('Dispensing \(name)')&#13;
    }&#13;
}&#13;
```&#13;
&#13;
调用 `vend` 的函数:&#13;
```swift&#13;
let favoriteSnacks = [&#13;
    'Alice': 'Chips',&#13;
    'Bob': 'Licorice',&#13;
    'Eve': 'Pretzels',&#13;
]&#13;
func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {&#13;
    let snackName = favoriteSnacks[person] ?? 'Candy Bar'&#13;
    try vendingMachine.vend(itemNamed: snackName)&#13;
}&#13;
```&#13;
需要使用 `try` 关键字&#13;
&#13;
结构体中传播错误:&#13;
```swift&#13;
struct PurchasedSnack {&#13;
    let name: String&#13;
    init(name: String, vendingMachine: VendingMachine) throws {&#13;
        try vendingMachine.vend(itemNamed: name)&#13;
        self.name = name&#13;
    }&#13;
}&#13;
```&#13;
### [使用 Do-Catch (Handling Errors Using Do-Catch)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/errorhandling/#Handling-Errors-Using-Do-Catch)&#13;
&#13;
```swift&#13;
var vendingMachine = VendingMachine()&#13;
vendingMachine.coinsDeposited = 8&#13;
do {&#13;
    try buyFavoriteSnack(person: 'Alice', vendingMachine: vendingMachine)&#13;
    print('Success! Yum.')&#13;
} catch VendingMachineError.invalidSelection {&#13;
    print('Invalid Selection.')&#13;
} catch VendingMachineError.outOfStock {&#13;
    print('Out of Stock.')&#13;
} catch VendingMachineError.insufficientFunds(let coinsNeeded) {&#13;
    print('Insufficient funds. Please insert an additional \(coinsNeeded) coins.')&#13;
} catch {&#13;
    print('Unexpected error: \(error).')&#13;
}&#13;
```&#13;
最后的 `catch` 用于处理意外情况&#13;
&#13;
`catch` 中匹配多个错误:&#13;
```swift&#13;
func eat(item: String) throws {&#13;
    do {&#13;
        try vendingMachine.vend(itemNamed: item)&#13;
    } catch VendingMachineError.invalidSelection, VendingMachineError.insufficientFunds, VendingMachineError.outOfStock {&#13;
        print('Invalid selection, out of stock, or not enough money.')&#13;
    }&#13;
}&#13;
```&#13;
### [转换错误为可选值 (Converting Errors to Optional Values)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/errorhandling/#Converting-Errors-to-Optional-Values)&#13;
&#13;
使用 `try?` 表达式, 如果发生错误则计算结果为 `nil`:&#13;
```swift&#13;
func someThrowingFunction() throws -&gt; Int {&#13;
    // ...&#13;
}&#13;
&#13;
let x = try? someThrowingFunction()&#13;
```&#13;
等同于:&#13;
```swift&#13;
let y: Int?&#13;
do {&#13;
    y = try someThrowingFunction()&#13;
} catch {&#13;
    y = nil&#13;
}&#13;
```&#13;
&#13;
用于条件表达式:&#13;
```swift&#13;
func fetchData() -&gt; Data? {&#13;
    if let data = try? fetchDataFromDisk() { return data }&#13;
    if let data = try? fetchDataFromServer() { return data }&#13;
    return nil&#13;
}&#13;
```&#13;
### [禁止错误传播 (Disabling Error Propagation)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/errorhandling/#Disabling-Error-Propagation)&#13;
&#13;
使用 `try!` 来表示不会发生错误:&#13;
```swift&#13;
let photo = try! loadImage(atPath: './Resources/John Appleseed.jpg')&#13;
```&#13;
如果发生错误将会直接报错, 错误也不会被传播出去&#13;
## [指定清除动作 (Specifying Cleanup Actions)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/errorhandling/#Specifying-Cleanup-Actions)&#13;
&#13;
使用 `defer` 将必要的清除动作包含在其中, 无论代码块是否正常退出都会执行&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D17%20-cuo-wu-chu-li.html</guid><pubDate>Wed, 24 Jul 2024 09:32:08 +0000</pubDate></item><item><title>[Swift 官方教程]16 可选值链</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D16%20-ke-xuan-zhi-lian.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
无需解包即可访问可选值的成员&#13;
## [可选值链作为强制解包的一种方式 (Optional Chaining as an Alternative to Forced Unwrapping)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/optionalchaining#Optional-Chaining-as-an-Alternative-to-Forced-Unwrapping)&#13;
&#13;
定义两个基类:&#13;
```swift&#13;
class Person {&#13;
    var residence: Residence?&#13;
}&#13;
&#13;
class Residence {&#13;
    var numberOfRooms = 1&#13;
}&#13;
```&#13;
&#13;
强制链式解包:&#13;
```swift&#13;
let john = Person()&#13;
let roomCount = john.residence!.numberOfRooms // 错误&#13;
```&#13;
&#13;
可选链式解包:&#13;
```swift&#13;
john.residence = Residence()&#13;
if let roomCount = john.residence?.numberOfRooms {&#13;
    print('John's residence has \(roomCount) room(s).')&#13;
} else {&#13;
    print('Unable to retrieve the number of rooms.')&#13;
}&#13;
```&#13;
## [为可选值链定义一个模型类 (Defining Model Classes for Optional Chaining)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/optionalchaining#Defining-Model-Classes-for-Optional-Chaining)&#13;
&#13;
居民:&#13;
```swift&#13;
class Person {&#13;
    var residence: Residence?&#13;
}&#13;
```&#13;
&#13;
居住登记:&#13;
```swift&#13;
class Residence {&#13;
    var rooms: [Room] = []&#13;
    var numberOfRooms: Int {&#13;
        return rooms.count&#13;
    }&#13;
    subscript(i: Int) -&gt; Room {&#13;
        get {&#13;
            return rooms[i]&#13;
        }&#13;
        set {&#13;
            rooms[i] = newValue&#13;
        }&#13;
    }&#13;
    func printNumberOfRooms() {&#13;
        print('The number of rooms is \(numberOfRooms)')&#13;
    }&#13;
    var address: Address?&#13;
}&#13;
```&#13;
&#13;
房间:&#13;
```swift&#13;
class Room {&#13;
    let name: String&#13;
    init(name: String) { self.name = name }&#13;
}&#13;
```&#13;
&#13;
地址:&#13;
```swift&#13;
class Address {&#13;
    var buildingName: String?&#13;
    var buildingNumber: String?&#13;
    var street: String?&#13;
    func buildingIdentifier() -&gt; String? {&#13;
        if let buildingNumber = buildingNumber, let street = street {&#13;
            return '\(buildingNumber) \(street)'&#13;
        } else if buildingName != nil {&#13;
            return buildingName&#13;
        } else {&#13;
            return nil&#13;
        }&#13;
    }&#13;
}&#13;
```&#13;
## [通过可选值链访问属性 (Accessing Properties Through Optional Chaining)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/optionalchaining#Accessing-Properties-Through-Optional-Chaining)&#13;
&#13;
访问居民的属性:&#13;
```swift&#13;
let john = Person()&#13;
if let roomCount = john.residence?.numberOfRooms {&#13;
    print('John's residence has \(roomCount) room(s).')&#13;
} else {&#13;
    print('Unable to retrieve the number of rooms.')&#13;
}&#13;
```&#13;
&#13;
通过可选值链为属性赋值:&#13;
```swift&#13;
let someAddress = Address()&#13;
someAddress.buildingNumber = '29'&#13;
someAddress.street = 'Acacia Road'&#13;
john.residence?.address = someAddress&#13;
```&#13;
因为 `address` 为 `nil`, 最后的赋值语句并不会执行计算&#13;
## [使用可选链来调用方法 (Calling Methods Through Optional Chaining)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/optionalchaining#Calling-Methods-Through-Optional-Chaining)&#13;
&#13;
通过可选链来调用方法:&#13;
```swift&#13;
if john.residence?.printNumberOfRooms() != nil {&#13;
    print('It was possible to print the number of rooms.')&#13;
} else {&#13;
    print('It was not possible to print the number of rooms.')&#13;
}&#13;
```&#13;
此时函数的返回值不是 `Void` 而是 `Void?`&#13;
&#13;
通过可选链赋值的整个表达式可以用于判断:&#13;
```swift&#13;
if (john.residence?.address = someAddress) != nil {&#13;
    print('It was possible to set the address.')&#13;
} else {&#13;
    print('It was not possible to set the address.')&#13;
}&#13;
```&#13;
## [通过可选链访问下标 (Accessing Subscripts Through Optional Chaining)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/optionalchaining#Accessing-Subscripts-Through-Optional-Chaining)&#13;
&#13;
因为 `residence?[0]` 为 `nil`, 下面的操作都会失败:&#13;
```swift&#13;
if let firstRoomName = john.residence?[0].name {&#13;
    print('The first room name is \(firstRoomName).')&#13;
} else {&#13;
    print('Unable to retrieve the first room name.')&#13;
}&#13;
```&#13;
&#13;
```swift&#13;
john.residence?[0] = Room(name: 'Bathroom')&#13;
```&#13;
&#13;
为 `residence` 赋值并访问下标:&#13;
```swift&#13;
&#13;
let johnsHouse = Residence()&#13;
johnsHouse.rooms.append(Room(name: 'Living Room'))&#13;
johnsHouse.rooms.append(Room(name: 'Kitchen'))&#13;
john.residence = johnsHouse&#13;
&#13;
if let firstRoomName = john.residence?[0].name {&#13;
    print('The first room name is \(firstRoomName).')&#13;
} else {&#13;
    print('Unable to retrieve the first room name.')&#13;
}&#13;
```&#13;
### [访问可选类型的下标 (Accessing Subscripts of Optional Type)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/optionalchaining#Accessing-Subscripts-of-Optional-Type)&#13;
&#13;
如果下标访问返回的是可选类型, 那么可以通过可选链访问它:&#13;
```swift&#13;
var testScores = ['Dave': [86, 82, 84], 'Bev': [79, 94, 81]]&#13;
testScores['Dave']?[0] = 91&#13;
testScores['Bev']?[0] += 1&#13;
testScores['Brian']?[0] = 72&#13;
```&#13;
字典的 key 下标返回的就是可选类型&#13;
## [连接多个层级的链 (Linking Multiple Levels of Chaining_](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/optionalchaining#Linking-Multiple-Levels-of-Chaining)&#13;
&#13;
```swift&#13;
if let johnsStreet = john.residence?.address?.street {&#13;
    print('John's street name is \(johnsStreet).')&#13;
} else {&#13;
    print('Unable to retrieve the address.')&#13;
}&#13;
```&#13;
&#13;
```swift&#13;
let johnsAddress = Address()&#13;
johnsAddress.buildingName = 'The Larches'&#13;
johnsAddress.street = 'Laurel Street'&#13;
john.residence?.address = johnsAddress&#13;
&#13;
&#13;
if let johnsStreet = john.residence?.address?.street {&#13;
    print('John's street name is \(johnsStreet).')&#13;
} else {&#13;
    print('Unable to retrieve the address.')&#13;
}&#13;
```&#13;
## [链接具有可选类型返回值的方法 (Chaining on Methods with Optional Return Values)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/optionalchaining#Chaining-on-Methods-with-Optional-Return-Values)&#13;
&#13;
通过可选链调用返回值是可选类型的方法:&#13;
```swift&#13;
if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {&#13;
    print('John's building identifier is \(buildingIdentifier).')&#13;
}&#13;
```&#13;
&#13;
更深一层的调用:&#13;
```swift&#13;
if let beginsWithThe =&#13;
    john.residence?.address?.buildingIdentifier()?.hasPrefix('The') {&#13;
    if beginsWithThe {&#13;
        print('John's building identifier begins with \'The\'.')&#13;
    } else {&#13;
        print('John's building identifier doesn't begin with \'The\'.')&#13;
    }&#13;
}&#13;
```&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D16%20-ke-xuan-zhi-lian.html</guid><pubDate>Wed, 24 Jul 2024 09:31:23 +0000</pubDate></item><item><title>[Swift 官方教程]15 析构函数</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D15%20-xi-gou-han-shu.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
在实例被回收前调用&#13;
## [析构函数如何工作 (How Deinitialization Works)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/deinitialization#How-Deinitialization-Works)&#13;
&#13;
Swift 利用'自动引用计数 (Automatic reference counting)' 自动回收不再使用的实例&#13;
&#13;
手动执行一些清理:&#13;
```swift&#13;
deinit{&#13;
	   &#13;
}&#13;
```&#13;
最多只能有一个&#13;
&#13;
超类的解初始化和被自动继承, 如果子类有实现会自动在实现的最后被调用&#13;
## [解初始化实际使用 (Deinitializers in Action)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/deinitialization#Deinitializers-in-Action)&#13;
&#13;
银行取钱和存钱:&#13;
```swift&#13;
class Bank {&#13;
    static var coinsInBank = 10_000&#13;
    static func distribute(coins numberOfCoinsRequested: Int) -&gt; Int {&#13;
        let numberOfCoinsToVend = min(numberOfCoinsRequested, coinsInBank)&#13;
        coinsInBank -= numberOfCoinsToVend&#13;
        return numberOfCoinsToVend&#13;
    }&#13;
    static func receive(coins: Int) {&#13;
        coinsInBank += coins&#13;
    }&#13;
}&#13;
```&#13;
&#13;
赌徒取钱和赢钱:&#13;
```swift&#13;
class Player {&#13;
    var coinsInPurse: Int&#13;
    init(coins: Int) {&#13;
        coinsInPurse = Bank.distribute(coins: coins)&#13;
    }&#13;
    func win(coins: Int) {&#13;
        coinsInPurse += Bank.distribute(coins: coins)&#13;
    }&#13;
    deinit {&#13;
        Bank.receive(coins: coinsInPurse)&#13;
    }&#13;
}&#13;
```&#13;
最后将钱返回给银行&#13;
&#13;
测试1:&#13;
```swift&#13;
var playerOne: Player? = Player(coins: 100)&#13;
print('A new player has joined the game with \(playerOne!.coinsInPurse) coins')&#13;
&#13;
print('There are now \(Bank.coinsInBank) coins left in the bank')&#13;
```&#13;
&#13;
测试2:&#13;
```swift&#13;
playerOne!.win(coins: 2_000)&#13;
print('PlayerOne won 2000 coins &amp; now has \(playerOne!.coinsInPurse) coins')&#13;
print('The bank now only has \(Bank.coinsInBank) coins left')&#13;
```&#13;
&#13;
测试3:&#13;
```swift&#13;
playerOne = nil&#13;
print('PlayerOne has left the game')&#13;
print('The bank now has \(Bank.coinsInBank) coins')&#13;
```&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D15%20-xi-gou-han-shu.html</guid><pubDate>Wed, 24 Jul 2024 09:30:20 +0000</pubDate></item><item><title>[Swift 官方教程]14 构造函数</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D14%20-gou-zao-han-shu.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
构造是一个实例被创建前的准备工作, 其通过构造函数实现&#13;
## [为存储值设置初始值 (Setting Initial Values for Stored Properties)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization#Setting-Initial-Values-for-Stored-Properties)&#13;
---&#13;
### [构造函数 (Initializers)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Initializers)&#13;
&#13;
🕐 使用 `init` 创建构造函数:&#13;
```swift&#13;
struct Db {&#13;
    var rows: Int&#13;
    init() {&#13;
        rows = 10&#13;
    }&#13;
}&#13;
```&#13;
&#13;
🕑 调用构造函数:&#13;
```swift&#13;
var db = Db()&#13;
print(db.rows) // 10&#13;
```&#13;
### [默认属性值 (Default Property Values)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Default-Property-Values)&#13;
&#13;
上述也可以直接通过属性赋默认值实现:&#13;
```swift&#13;
struct Db {&#13;
    var rows = 10&#13;
}&#13;
```&#13;
&#13;
&gt; 如果实例中的属性的默认值总是固定的, 那么最好使用'默认属性值'; 从语法和性能上都更佳&#13;
## [定制构造函数 (Customizing Initialization)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Customizing-Initialization)&#13;
---&#13;
### [初始化参数 (Initialization Parameters)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Initialization-Parameters)&#13;
&#13;
可以给构造函数添加参数:&#13;
```swift&#13;
struct Exchange {&#13;
    var n: Double&#13;
    init(fromUS x: Double) {&#13;
        n = x * 7.12&#13;
    }&#13;
    init(fromJP y: Double) {&#13;
        n = y * 0.0048&#13;
    }&#13;
}&#13;
&#13;
let s1 = Exchange(fromUS: 100)&#13;
let s2 = Exchange(fromJP: 100)&#13;
print(s1.n, s2.n)&#13;
```&#13;
### [参数名和实参标签 (Parameter Names and Argument Labels)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Parameter-Names-and-Argument-Labels)&#13;
&#13;
🕐 通过参数名和类型来区分多个构造函数:&#13;
```swift&#13;
struct Point {&#13;
    let x, y, z: Double&#13;
    init(x: Double, y: Double, z: Double) {&#13;
        self.x = x&#13;
        self.y = y&#13;
        self.z = z&#13;
    }&#13;
    init(s: Double) {&#13;
        x = s&#13;
        y = s&#13;
        z = s&#13;
    }&#13;
}&#13;
```&#13;
&#13;
🕑 调用时必须指明实参标签:&#13;
```swift&#13;
let a = Point(x: 1.0, y: 2.1, z: 3.2)&#13;
let b = Point(s: 1.8)&#13;
```&#13;
如果没有设置实参标签, 则会自动将参数名设置为实参标签&#13;
### [忽略实参标签 (Initializer Parameters Without Argument Labels)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Initializer-Parameters-Without-Argument-Labels)&#13;
&#13;
使用 `_` 忽略实参标签:&#13;
```swift&#13;
struct Db {&#13;
    var rows: Int&#13;
    init(_ num: Int) {&#13;
        rows = num&#13;
    }&#13;
}&#13;
&#13;
var db = Db(10)&#13;
```&#13;
### [可选值类型 (Optional Property Types)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Optional-Property-Types)&#13;
&#13;
可选值类型在初始化时会自动赋值为 `nil`&#13;
### [初始化时访问常量值 (Assigning Constant Properties During Initialization)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Assigning-Constant-Properties-During-Initialization)&#13;
&#13;
常量一旦赋值后就不能再修改&#13;
## [默认构造函数 (Default Initializers)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Default-Initializers)&#13;
---&#13;
`struct` 或 `class` 会自动提供构造函数来完成属性值赋值的过程 (当没有自定义构造函数时)&#13;
### [结构体的成员式构造函数 (Memberwise Initializers for Structure Types)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Memberwise-Initializers-for-Structure-Types)&#13;
🕐 没有其他初构造函数时, 结构体会自动为每个属性提供构造函数:&#13;
```swift&#13;
struct Point {&#13;
    var x = 0.0, y = 0.0&#13;
}&#13;
```&#13;
&#13;
🕑 调用其构造函数:&#13;
```swift&#13;
let point1 = Point(y: 20.0)&#13;
let point2 = Point(x: 10.0)&#13;
let point3 = Point(x: 3.0, y: 4.0)&#13;
```&#13;
## [值类型的初始化委派 (Initializer Delegation for Value Types)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Initializer-Delegation-for-Value-Types)&#13;
---&#13;
🕐 构造函数中可以调用其他构造函数, 使用 `self.init()`&#13;
&#13;
🕑 如果自定义了构造函数, 则默认构造函数或成员式构造函数将不可用&#13;
### 示例&#13;
&#13;
🕐 定义一个包含 3 个构造函数的值类型:&#13;
```swift&#13;
struct Point {&#13;
    var x = 0.0&#13;
    var y = 0.0&#13;
    var z = 0.0&#13;
    init() {}&#13;
    init(x: Double, y: Double, z: Double) {&#13;
        self.x = x&#13;
        self.y = y&#13;
        self.z = z&#13;
    }&#13;
    init(x: Double, y: Double) {&#13;
        let newX = x * 10&#13;
        let newY = y * 5&#13;
        let newZ = (newX * newY) / 2&#13;
        self.init(x: newX, y: newY, z: newZ)&#13;
    }&#13;
}&#13;
```&#13;
&#13;
🕐 调用其无参构造函数 (行为同默认构造函数):&#13;
```swift&#13;
var p1 = Point()&#13;
```&#13;
&#13;
🕑 调用其有参构造函数 (行为同成员式构造函数):&#13;
```swift&#13;
var p2 = Point(x: 1.2, y: 1.6, z: 2.8)&#13;
```&#13;
&#13;
🕒 调用具有初始化委派行为的构造函数:&#13;
```swift&#13;
var p3 = Point(x: 3.2, y: 2.1)&#13;
```&#13;
## [类的继承和构造 (Class Inheritance and Initialization)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Class-Inheritance-and-Initialization)&#13;
---&#13;
要确保本身定义的值和继承来的值在构造后都具有初始值&#13;
### [设计构造函数和便利构造函数 (Designated Initializers and Convenience Initializers)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Designated-Initializers-and-Convenience-Initializers)&#13;
&#13;
- 设计构造函数: 确保所有属性被构造化 (必须要有一个)&#13;
- 便利构造函数: 调用设计构造函数, 对构造过程进行简化, (按情况添加)&#13;
### [设计构造函数和便利构造函数的语法 (Syntax for Designated and Convenience Initializers)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Syntax-for-Designated-and-Convenience-Initializers)&#13;
&#13;
🕐 设计构造函数:&#13;
```swift&#13;
init(&lt;#parameters#&gt;) {&#13;
   &lt;#statements#&gt;&#13;
}&#13;
```&#13;
&#13;
🕑 便利构造函数:&#13;
```swift&#13;
convenience init(&lt;#parameters#&gt;) {&#13;
   &lt;#statements#&gt;&#13;
}&#13;
```&#13;
### [类的构造委托 (Initializer Delegation for Class Types)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Initializer-Delegation-for-Class-Types)&#13;
&#13;
🕐 设计构造函数和便利构造函数符合以下 3 条规则:&#13;
- 设计构造函数必须从其直接父类中调用一个设计构造函数&#13;
- 便利构造函数只能调用当前类中其他的构造函数&#13;
- 便利构造函数最终一定会调用一个设计构造函数&#13;
&#13;
🕑 如下图所示:&#13;
![[Pasted image 20240122133125.png|400]]&#13;
&#13;
🕒 更复杂的形式:&#13;
![[Pasted image 20240125110357.png|400]]&#13;
### [构造的两个阶段 (Two-Phase Initialization)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Two-Phase-Initialization)&#13;
&#13;
🕐 构造分为两个阶段:&#13;
1. 给所有存储属性值赋值&#13;
2. 对实例中的属性进行修改 (定制操作)&#13;
&#13;
🕑 为了确保构造的安全, 编译器会进行以下 4 个检查:&#13;
- 在调用父类的设计构造函数前, 必须确保通过自身的设计构造函数将为所有属性设定初始化值&#13;
- 在给继承属性赋值之前必须先调用父类的设计构造函数, 否则会被父类的设计构造函数覆盖掉&#13;
- 便利构造函数在给任何属性赋值前必须先调用其他构造函数, 否则会被自身的设计构造函数覆盖&#13;
- 只有构造的第一阶段结束后, 才能调用实例中的方法, 访问实例中的属性值等&#13;
&#13;
🕒 这是一个构造第一阶段的调用链图示, 确保所有属性值都有初始值:&#13;
![[Pasted image 20240125140333.png|400]]&#13;
&#13;
随后第二阶段的定制操作开始执行:&#13;
![[Pasted image 20240125140508.png|400]]&#13;
### [构造函数的继承与重写 (Initializer Inheritance and Overriding)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Initializer-Inheritance-and-Overriding)&#13;
&#13;
- 默认子类不会继承超类的构造函数, 因为超类的构造函数不一定能够满足子类的要求&#13;
- 如果子类的设计构造函数与超类的设计构造函数相同, 要加上 `override`&#13;
- 如果子类的构造函数与父类的便利构造函数相同, 不需要加 `override`, 因为按照之前的规则, 子类是无法直接调用父类的便利构造函数&#13;
#### 示例&#13;
&#13;
🕐 定义一个基类并调用:&#13;
```swift&#13;
class Pet {&#13;
    var age = 0&#13;
    var say: String {&#13;
        return 'I'm \(age) years old.'&#13;
    }&#13;
}&#13;
&#13;
var p = Pet()&#13;
print(p.say) // I'm 0 years old.&#13;
```&#13;
这里自动提供了设计构造函数&#13;
&#13;
🕑 创建一个子类并重写基类的设计构造函数:&#13;
```swift&#13;
class Cat: Pet {&#13;
    override init() {&#13;
        super.init()&#13;
        age = 2&#13;
    }&#13;
}&#13;
&#13;
var c = Cat()&#13;
print(c.say) // I'm 2 years old.&#13;
```&#13;
因为重写了基类的设计构造函数, 因而需要 `override`&#13;
&#13;
🕒 创建一个子类隐式调用基类的设计构造函数:&#13;
```swift&#13;
class Dog: Pet {&#13;
    var name: String&#13;
    init(name: String) {&#13;
        self.name = name&#13;
        // super.init() 隐式调用&#13;
    }&#13;
    override var say: String {&#13;
        return '\(super.say) And call me \(name)'&#13;
    }&#13;
}&#13;
&#13;
var d = Dog(name: 'Chichi')&#13;
print(d.say) // I'm 0 years old. And call me Chichi&#13;
```&#13;
因为子类没有进行定制操作, 所以基类的设计构造函数会被隐式调用&#13;
### [构造函数的自动继承 (Automatic Initializer Inheritance)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Automatic-Initializer-Inheritance)&#13;
&#13;
如果子类中新增的属性都提供了默认值, 则:&#13;
- 子类没有提供设计构造函数, 则超类的设计构造函数会被自动继承&#13;
- 子类实现或继承了其超类的所有的设计构造函数, 则自动继承超类的所有便利构造函数&#13;
### [设计构造函数和便利构造函数的应用 (Designated and Convenience Initializers in Action)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Designated-and-Convenience-Initializers-in-Action)&#13;
&#13;
🕐 基类:&#13;
```swift&#13;
class Food {&#13;
    var name: String&#13;
    init(name: String) {&#13;
        self.name = name&#13;
    }&#13;
    convenience init() {&#13;
        self.init(name: '[Unnamed]')&#13;
    }&#13;
}&#13;
```&#13;
&#13;
![[Pasted image 20240122171918.png|400]]&#13;
&#13;
🕑 创建 `Food` 的子类, 重写 `init` 为便利构造函数:&#13;
```swift&#13;
class RecipeIngredient: Food {&#13;
    var quantity: Int&#13;
    init(name: String, quantity: Int) {&#13;
        self.quantity = quantity&#13;
        super.init(name: name)&#13;
    }&#13;
    override convenience init(name: String) {&#13;
        self.init(name: name, quantity: 1)&#13;
    }&#13;
}&#13;
```&#13;
&#13;
![[Pasted image 20240122172017.png|400]]&#13;
&#13;
🕒 创建 `RecipeIngredient` 的子类:&#13;
```swift&#13;
class ShoppingListItem: RecipeIngredient {&#13;
    var purchased = false&#13;
    var description: String {&#13;
        var output = '\(quantity) x \(name)'&#13;
        output += purchased ? ' ✔' : ' ✘'&#13;
        return output&#13;
    }&#13;
}&#13;
```&#13;
因为其所有属性都具有默认值, 并且没有自定义任何构造函数, 因而自动继承超类的构造函数&#13;
&#13;
![[Pasted image 20240122172224.png|400]]&#13;
## [可失败的构造函数 (Failable Initializers)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Failable-Initializers)&#13;
&#13;
🕐 使用 `?` 标记该构造函数可能会失败, 此时将返回该实例类型的可选值:&#13;
```swift&#13;
struct Pet {&#13;
    let name: String&#13;
    init?(name: String) {&#13;
        if name.isEmpty { return nil }&#13;
        self.name = name&#13;
    }&#13;
}&#13;
```&#13;
使用 `retrun nil` 表示构造失败&#13;
&#13;
🕑 调用并解包可选值:&#13;
```swift&#13;
let c = Pet(name: 'mimi')&#13;
&#13;
if let cat = c {&#13;
    print(cat.name)&#13;
}&#13;
```&#13;
&#13;
🕒 可选值为空可直接判断:&#13;
```swift&#13;
let d = Pet(name: '')&#13;
&#13;
if d == nil {&#13;
    print('error')&#13;
}&#13;
```&#13;
### [枚举类的可失败构造函数 (Failable Initializers for Enumerations)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Failable-Initializers-for-Enumerations)&#13;
&#13;
🕐 基础示例:&#13;
```swift&#13;
enum Pet {&#13;
    case cat, dog, rabbit&#13;
    init?(type: Character) {&#13;
        switch type {&#13;
        case 'c':&#13;
            self = .cat&#13;
        case 'd':&#13;
            self = .dog&#13;
        case 'r':&#13;
            self = .rabbit&#13;
        default:&#13;
            return nil&#13;
        }&#13;
    }&#13;
}&#13;
```&#13;
&#13;
🕑 调用示例:&#13;
```swift&#13;
let p = Pet(type: 'c')&#13;
if p != nil {&#13;
    print('cat')&#13;
}&#13;
```&#13;
### [带原始值的枚举类的可失败构造函数 (Failable Initializers for Enumerations with Raw Values)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Failable-Initializers-for-Enumerations-with-Raw-Values)&#13;
&#13;
带有原始值的枚举类会自动接受 `init?(rawValue: )`&#13;
&#13;
🕐 采用这种方式对上面的枚举类重写:&#13;
```swift&#13;
enum Pet: Character {&#13;
    case cat = 'c', dog = 'd', rabbit = 'r'&#13;
}&#13;
```&#13;
&#13;
🕑 调用示例:&#13;
```swift&#13;
let p = Pet(rawValue: 'c')&#13;
if p != nil {&#13;
    print('cat')&#13;
}&#13;
```&#13;
### [初始化失败的传播 (Propagation of Initialization Failure)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Propagation-of-Initialization-Failure)&#13;
&#13;
简单的说就是通过继承链或调用链进行传播&#13;
&#13;
🕐 创建一个基类:&#13;
```swift&#13;
class Pet {&#13;
    let name: String&#13;
    init?(name: String) {&#13;
        if name.isEmpty {return nil}&#13;
        self.name = name&#13;
    }&#13;
}&#13;
```&#13;
&#13;
🕑 一个子类调用基类的可失败构造函数:&#13;
```swift&#13;
class Cat: Pet {&#13;
    let age: Int&#13;
    init?(name: String, age: Int) {&#13;
        if age &lt; 2 { return nil }&#13;
        self.age = age&#13;
        super.init(name: name)&#13;
    }&#13;
}&#13;
```&#13;
因为子类的构造函数是可失败的, 其才能够调用基类的可失败构造函数, 并且不需要加 `?`&#13;
&#13;
🕒 调用示例:&#13;
```swift&#13;
if let c = Cat(name: 'mimi', age: 10) {&#13;
    print(c.name, c.age)&#13;
}&#13;
```&#13;
### [重写可失败的构造函数 (Overriding a Failable Initializer)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Overriding-a-Failable-Initializer)&#13;
&#13;
子类可以重写父类的可失败构造函数为普通构造函数, 反之不行&#13;
&#13;
🕐 简单示例, 创建一个基类:&#13;
```swift&#13;
class Pet {&#13;
    var name: String?&#13;
    init() {}&#13;
    init?(name: String) {&#13;
        if name.isEmpty { return nil }&#13;
        self.name = name&#13;
    }&#13;
}&#13;
```&#13;
&#13;
🕑 创建一个子类重写基类的构造函数:&#13;
```swift&#13;
class Cat: Pet {&#13;
    override init() {&#13;
        super.init()&#13;
        self.name = '[Unknown]'&#13;
    }&#13;
    override init(name: String) {&#13;
        super.init()&#13;
        if name.isEmpty {&#13;
            self.name = '[Unknown]'&#13;
        } else {&#13;
            self.name = name&#13;
        }&#13;
    }&#13;
}&#13;
```&#13;
&#13;
🕒 创建一个子类重写基类的构造函数, 并调用基类的可失败构造函数:&#13;
```swift&#13;
class Dog: Pet {&#13;
    override init() {&#13;
        super.init(name: '[Unknown]')!&#13;
    }&#13;
}&#13;
```&#13;
此时要加上 `!`, 这表示你认为这样已经绝对安全了&#13;
### [隐式解包的可失败构造函数 (The init! Failable Initializer)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#The-init-Failable-Initializer)&#13;
&#13;
也就是 `init!()`&#13;
## [必要的构造函数 (Required Initializers)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Required-Initializers)&#13;
&#13;
🕐 在构造函数前使用 `required` 关键字标明子类都必须要实现该构造函数:&#13;
```swift&#13;
class SomeClass {&#13;
    required init() {&#13;
        // initializer implementation goes here&#13;
    }&#13;
}&#13;
```&#13;
&#13;
🕑 在子类中实现该构造函数也必须加上 `required`, 此时不必使用 `override`&#13;
```swift&#13;
class SomeSubclass: SomeClass {&#13;
    required init() {&#13;
        // subclass implementation of the required initializer goes here&#13;
    }&#13;
}&#13;
```&#13;
## [使用闭包或函数设置一个默认值 (Setting a Default Property Value with a Closure or Function)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization/#Setting-a-Default-Property-Value-with-a-Closure-or-Function)&#13;
&#13;
🕐 基本结构:&#13;
```swift&#13;
class SomeClass {&#13;
    let someProperty: SomeType = {&#13;
        return someValue&#13;
    }()&#13;
}&#13;
```&#13;
&#13;
🕑 闭包是在构造的过程中执行的, 这意味着此时其他属性不一定都构造完成了, 因而不能在其中调用其它属性或使用 `self`&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D14%20-gou-zao-han-shu.html</guid><pubDate>Wed, 24 Jul 2024 09:29:09 +0000</pubDate></item><item><title>[Swift 官方教程]13 继承</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D13%20-ji-cheng.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
## [定义基类 (Defining a Base Class)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/inheritance#Defining-a-Base-Class)&#13;
---&#13;
```swift&#13;
class Pet {&#13;
    var name: String = 'Pet'&#13;
    var age = 0.0&#13;
    var description: String {&#13;
        return 'My name is \(name), I'm \(age) years old.'&#13;
    }&#13;
    &#13;
    func eat() {&#13;
    }&#13;
}&#13;
```&#13;
## [子类 (Subclassing)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/inheritance#Subclassing)&#13;
---&#13;
```swift&#13;
class Cat: Pet {&#13;
    var value = 18.4&#13;
}&#13;
```&#13;
&#13;
```swift&#13;
let cat = Cat()&#13;
cat.name = 'mimi'&#13;
cat.age = 2.3&#13;
print(cat.description)&#13;
```&#13;
## [重写 (Overriding)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/inheritance#Overriding)&#13;
---&#13;
使用 `override`&#13;
### [访问超类的方法, 属性和下标 (Accessing Superclass Methods, Properties, and Subscripts)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/inheritance#Accessing-Superclass-Methods-Properties-and-Subscripts)&#13;
&#13;
使用 `super`:&#13;
- 方法: `super.method()`&#13;
- 属性: `super.properties`&#13;
- 下标: `super[index]`&#13;
### [重写方法 (Overriding Methods)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/inheritance#Overriding-Methods)&#13;
&#13;
```swift&#13;
class Dog: Pet {&#13;
    override func eat() {&#13;
        print('I like bones.')&#13;
    }&#13;
}&#13;
let dog = Dog()&#13;
dog.eat()&#13;
```&#13;
### [重写属性 (Overriding Properties)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/inheritance#Overriding-Properties)&#13;
#### [重写属性的 Getters 和 Setters (Overriding Property Getters and Setters)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/inheritance#Overriding-Property-Getters-and-Setters)&#13;
&#13;
判断是否属于重写的依据是属性名和其类型:&#13;
```swift&#13;
class Rabbit: Pet {&#13;
    var color = 'white'&#13;
    override var description: String {&#13;
        return super.description + 'My color is \(color)'&#13;
    }&#13;
}&#13;
&#13;
let rabbit = Rabbit()&#13;
rabbit.name = 'Nity'&#13;
rabbit.age = 1.5&#13;
print(rabbit.description)&#13;
```&#13;
#### [重写属性观察器 (Overriding Property Observers)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/inheritance#Overriding-Property-Observers)&#13;
&#13;
```swift&#13;
class Pig: Pet {&#13;
    var weight = 1.8&#13;
    override var age: Double {&#13;
        didSet {&#13;
            weight = weight * age&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
let pig = Pig()&#13;
pig.age = 10&#13;
print(pig.weight)&#13;
```&#13;
## [防止被重写 (Preventing Overrides)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/inheritance#Preventing-Overrides)&#13;
&#13;
使用 `final`&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D13%20-ji-cheng.html</guid><pubDate>Wed, 24 Jul 2024 09:28:23 +0000</pubDate></item><item><title>[Swift 官方教程]12 下标</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D12%20-xia-biao.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
## [下标语法 (Subscript Syntax)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/subscripts#Subscript-Syntax)&#13;
&#13;
🕐 使用 `subscript` 自定义下标查询逻辑:&#13;
```swift&#13;
struct MyStruct {&#13;
    let multi: Int&#13;
    subscript(num: Int) -&gt; Int {&#13;
        return multi * num&#13;
    }&#13;
}&#13;
```&#13;
&#13;
🕑 通过方括号对实例进行查询:&#13;
```swift&#13;
let s = MyStruct(multi: 3)&#13;
print(s[6]) // 18&#13;
```&#13;
## [下标使用场景  (Subscript Usage)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/subscripts#Subscript-Usage)&#13;
&#13;
取决于你自己&#13;
## [下标操作 (Subscript Options)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/subscripts#Subscript-Options)&#13;
&#13;
🕐 可以像函数一样使用 `subscript`, 只是不能使用 `in-out` 参数. 可以在类型中定义多个 `subscript` 实现, 调用时会根据参数自动匹配&#13;
&#13;
🕑 下面是自定义二维矩阵的实现:&#13;
```swift&#13;
struct Matrix {&#13;
    let rows: Int, columns: Int&#13;
    var grid: [Double]&#13;
    init(rows: Int, columns: Int) {&#13;
        self.rows = rows&#13;
        self.columns = columns&#13;
        grid = Array(repeating: 0.0, count: rows * columns)&#13;
    }&#13;
    func indexIsValid(row: Int, column: Int) -&gt; Bool {&#13;
        return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns&#13;
    }&#13;
    subscript(row: Int, column: Int) -&gt; Double {&#13;
        get {&#13;
            assert(indexIsValid(row: row, column: column), 'Index out of range')&#13;
            return grid[(row * columns) + column]&#13;
        }&#13;
        set {&#13;
            assert(indexIsValid(row: row, column: column), 'Index out of range')&#13;
            grid[(row * columns) + column] = newValue&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
var matrix = Matrix(rows: 2, columns: 2)&#13;
matrix[0, 1] = 1.5&#13;
matrix[1, 0] = 3.2&#13;
&#13;
let someValue = matrix[2, 2] // 报错&#13;
```&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D12%20-xia-biao.html</guid><pubDate>Wed, 24 Jul 2024 09:27:38 +0000</pubDate></item><item><title>[Swift 官方教程]11 方法</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D11%20-fang-fa.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
## [实例方法 (Instance Methods)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/methods#Instance-Methods)&#13;
---&#13;
属于实例的方法&#13;
### [`self` 属性 (The self Property)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/methods#The-self-Property)&#13;
&#13;
`self` 指向自身实例, 一般用于区分同名的量&#13;
```swift&#13;
struct Point {&#13;
    var x = 0.0, y = 0.0&#13;
    func compare(x: Double) -&gt; Bool {&#13;
        return self.x &gt; x&#13;
    }&#13;
}&#13;
```&#13;
### [在实例方法中修改值类型 (Modifying Value Types from Within Instance Methods)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/methods#Modifying-Value-Types-from-Within-Instance-Methods)&#13;
&#13;
默认情况下, 值类型中的方法不能修改值类型的属性, 但可以通过 `mutating` 实现:&#13;
```swift&#13;
struct Point {&#13;
    var x = 0.0, y = 0.0&#13;
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {&#13;
        x += deltaX&#13;
        y += deltaY&#13;
    }&#13;
}&#13;
var somePoint = Point(x: 1.0, y: 1.0)&#13;
somePoint.moveBy(x: 2.0, y: 3.0)&#13;
```&#13;
&#13;
&gt; 这里给出个人理解, 因为值类型就是一个值, 你调用了其中的方法对其进行修改, 那么之前的赋值就变了, 而值应该是保持不变的, 所以这么做更加的安全&#13;
### [在可变方法中给 `self` 赋值 (Assigning to self Within a Mutating Method)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/methods#Assigning-to-self-Within-a-Mutating-Method)&#13;
&#13;
🕐 可以直接给 `self` 赋值, 这是上述代码的另一种实现:&#13;
```swift&#13;
struct Point {&#13;
    var x = 0.0, y = 0.0&#13;
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {&#13;
        self = Point(x: x + deltaX, y: y + deltaY)&#13;
    }&#13;
}&#13;
```&#13;
&#13;
在🕑 枚举中的用法:&#13;
```swift&#13;
enum TriStateSwitch {&#13;
    case off, low, high&#13;
    mutating func next() {&#13;
        switch self {&#13;
        case .off:&#13;
            self = .low&#13;
        case .low:&#13;
            self = .high&#13;
        case .high:&#13;
            self = .off&#13;
        }&#13;
    }&#13;
}&#13;
var ovenLight = TriStateSwitch.low&#13;
ovenLight.next()&#13;
ovenLight.next()&#13;
```&#13;
## [类型方法 (Type Methods)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/methods#Type-Methods)&#13;
&#13;
即属于类型的方法, 在方法前使用 `static` , 对于类也可以使用 `class`&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D11%20-fang-fa.html</guid><pubDate>Wed, 24 Jul 2024 09:26:48 +0000</pubDate></item><item><title>[Swift 官方教程]10 属性</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D10%20-shu-xing.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
**Stored Properties** 由类和结构体提供, **Computed Properties** 由类,结构体和枚举提供&#13;
## [存储型属性 (Stored Properties)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties#Stored-Properties)&#13;
---&#13;
实例中的变量或常量&#13;
```swift&#13;
struct FixedLengthRange {&#13;
    var firstValue: Int&#13;
    let length: Int&#13;
}&#13;
```&#13;
### [常量结构实例的存储型属性 (Stored Properties of Constant Structure Instances)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties#Stored-Properties-of-Constant-Structure-Instances)&#13;
&#13;
如果一个实例是常量类型, 无法修改其 **stored properties**&#13;
### [惰性存储型属性 (Lazy Stored Properties)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties#Lazy-Stored-Properties)&#13;
&#13;
即 **stored properties** 值在它被第一次使用时才进行计算, 且必须是 `var`, 因为常量必须在初始化完成之前总是具有值:&#13;
```swift&#13;
class DataImporter {&#13;
    var filename = 'data.txt'&#13;
}&#13;
&#13;
class DataManager {&#13;
    lazy var importer = DataImporter()&#13;
    var data: [String] = []&#13;
}&#13;
```&#13;
### [存储型属性和实例变量 (Stored Properties and Instance Variables)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties#Stored-Properties-and-Instance-Variables)&#13;
&#13;
Swift 和 Oc 之间属性和实例变量的操作差异, 不管&#13;
## [计算型属性 (Computed Properties)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties#Computed-Properties)&#13;
---&#13;
即通过计算得到的值, 并不是直接赋值存储的:&#13;
```swift&#13;
struct MyStruct {&#13;
    var a: Int&#13;
    var b: Int&#13;
    var c: Int {&#13;
        get {&#13;
            let m = a * 10&#13;
            let n = b * 10&#13;
            return m + n&#13;
        }&#13;
        set(num) {&#13;
            a = num / 10&#13;
            b = num / 2&#13;
        }&#13;
    }&#13;
}&#13;
```&#13;
&#13;
访问 **computed properties** 是调用其 `get` 方法:&#13;
```swift&#13;
var s = MyStruct(a: 3, b: 5)&#13;
print(s.c) // 80&#13;
```&#13;
&#13;
访问 **computed properties** 是调用其 `set` 方法:&#13;
```swift&#13;
s.c = 10&#13;
print(s.a, s.b) // 1 5&#13;
```&#13;
### [更简洁的 Setter 声明 (Shorthand Setter Declaration)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties/#Shorthand-Setter-Declaration)&#13;
&#13;
`set` 中的参数可以被 `newValue` 替代:&#13;
```swift&#13;
struct MyStruct {&#13;
    var a: Int&#13;
    var b: Int&#13;
    var c: Int {&#13;
        get {&#13;
            let m = a * 10&#13;
            let n = b * 10&#13;
            return m + n&#13;
        }&#13;
        set {&#13;
            a = newValue / 10&#13;
            b = newValue / 2&#13;
        }&#13;
    }&#13;
}&#13;
```&#13;
### [更简短的 Getter 声明 (Shorthand Getter Declaration)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties/#Shorthand-Getter-Declaration)&#13;
&#13;
`get` 中的如果是单行表达式, 则可以简写:&#13;
```swift&#13;
struct MyStruct {&#13;
    var a: Int&#13;
    var b: Int&#13;
    var c: Int {&#13;
        get {&#13;
            a*10 + b*10&#13;
        }&#13;
        set {&#13;
            a = newValue / 10&#13;
            b = newValue / 2&#13;
        }&#13;
    }&#13;
}&#13;
```&#13;
### [仅可读的计算型属性 (Read-Only Computed Properties)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties/#Read-Only-Computed-Properties)&#13;
&#13;
一个计算值没有 `set` 方法则为仅可读的, 此时可以对 `get` 进行略写:&#13;
```swift&#13;
struct MyStruct {&#13;
    var a: Int&#13;
    var b: Int&#13;
    var c: Int {&#13;
        a*10 + b*10&#13;
    }&#13;
}&#13;
```&#13;
## [属性观察器 (Property Observers)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties/#Property-Observers)&#13;
---&#13;
🕐 在属性被修改的前后被调用. 它可以应用的对象:&#13;
- 自定义的 **stored properties**&#13;
- 继承来的 **stored properties** 和 **computed properties***&#13;
对于自定义的 **computed properties***, 应该在 `set` 中对其进行观察&#13;
&#13;
🕑 有以下 2 种观察者:&#13;
- `willSet`: 值被存储前调用; 默认有 `newValue` 参数表示要设置的新值&#13;
- `didSet`: 值被存储后调用; 默认有 `oldValue` 参数表示被替换的旧值&#13;
&#13;
🕒 一个总和增加便提示差值的示例:&#13;
```swift&#13;
class Counter {&#13;
    var total: Int = 0 {&#13;
        willSet(newNum) {&#13;
            print('Set total to \(newNum)')&#13;
        }&#13;
        didSet {&#13;
            if total &gt; oldValue  {&#13;
                print('Added \(total - oldValue) steps')&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
let c = Counter()&#13;
c.total = 200&#13;
c.total = 100&#13;
c.total = 300&#13;
```&#13;
&#13;
🕓 对于观察者在父子类中的调用, 以及 `in-out` 的值的细节, 用到再说&#13;
## [属性包装器 (Property Wrappers)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties/#Property-Wrappers)&#13;
---&#13;
🕐 使用 `@propertyWrapper` 和 `wrappedValue` 定义一个属性包装器:&#13;
```swift&#13;
@propertyWrapper&#13;
struct TwelveOrLess {&#13;
    private var number = 0&#13;
    var wrappedValue: Int {&#13;
        get { number }&#13;
        set { number = min(newValue, 12) }&#13;
    }&#13;
}&#13;
```&#13;
随后将其运用在属性上:&#13;
```swift&#13;
struct SmallRectangle {&#13;
    @TwelveOrLess var height: Int&#13;
    @TwelveOrLess var width: Int&#13;
}&#13;
```&#13;
访问该属性实际上是访问对应的包装器的 `wrappedValue`:&#13;
```swift&#13;
var rectangle = SmallRectangle()&#13;
print(rectangle.height) // 0&#13;
&#13;
rectangle.height = 999&#13;
print(rectangle.height) // 12&#13;
```&#13;
&#13;
🕑 以上等价于:&#13;
```swift&#13;
struct SmallRectangle {&#13;
    private var _height = TwelveOrLess()&#13;
    private var _width = TwelveOrLess()&#13;
    var height: Int {&#13;
        get { return _height.wrappedValue }&#13;
        set { _height.wrappedValue = newValue }&#13;
    }&#13;
    var width: Int {&#13;
        get { return _width.wrappedValue }&#13;
        set { _width.wrappedValue = newValue }&#13;
    }&#13;
}&#13;
```&#13;
### [为被包装的属性设置Setting Initial Values for Wrapped Properties)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties/#Setting-Initial-Values-for-Wrapped-Properties)&#13;
&#13;
上述代码中被包装的属性不能设定初始值, 下面通过为包装器添加初始化值的方法实现:&#13;
```swift&#13;
@propertyWrapper&#13;
struct SmallNumber {&#13;
    private var maximum: Int&#13;
    private var number: Int&#13;
&#13;
&#13;
    var wrappedValue: Int {&#13;
        get { return number }&#13;
        set { number = min(newValue, maximum) }&#13;
    }&#13;
&#13;
&#13;
    init() {&#13;
        maximum = 12&#13;
        number = 0&#13;
    }&#13;
    init(wrappedValue: Int) {&#13;
        maximum = 12&#13;
        number = min(wrappedValue, maximum)&#13;
    }&#13;
    init(wrappedValue: Int, maximum: Int) {&#13;
        self.maximum = maximum&#13;
        number = min(wrappedValue, maximum)&#13;
    }&#13;
}&#13;
```&#13;
&#13;
🕐 调用 `init()`:&#13;
```swift&#13;
struct ZeroRectangle {&#13;
    @SmallNumber var height: Int&#13;
    @SmallNumber var width: Int&#13;
}&#13;
&#13;
var zeroRectangle = ZeroRectangle()&#13;
print(zeroRectangle.height, zeroRectangle.width)&#13;
```&#13;
&#13;
🕑 调用 `init(wrappedValue:)`:&#13;
```swift&#13;
struct UnitRectangle {&#13;
    @SmallNumber var height: Int = 1&#13;
    @SmallNumber var width: Int = 1&#13;
}&#13;
&#13;
var unitRectangle = UnitRectangle()&#13;
print(unitRectangle.height, unitRectangle.width)&#13;
```&#13;
这里的 `wrappedValue` 指的就是被包装属性的初始值&#13;
&#13;
🕒 调用 `init(wrappedValue:maximum:)`:&#13;
```swift&#13;
struct NarrowRectangle {&#13;
    @SmallNumber(wrappedValue: 2, maximum: 5) var height: Int&#13;
    @SmallNumber(wrappedValue: 3, maximum: 4) var width: Int&#13;
}&#13;
&#13;
var narrowRectangle = NarrowRectangle()&#13;
print(narrowRectangle.height, narrowRectangle.width)&#13;
```&#13;
&#13;
🕓 上述方式可以灵活混合使用:&#13;
```swift&#13;
struct MixedRectangle {&#13;
    @SmallNumber var height: Int = 1&#13;
    @SmallNumber(maximum: 9) var width: Int = 2&#13;
}&#13;
&#13;
var mixedRectangle = MixedRectangle()&#13;
print(mixedRectangle.height, mixedRectangle.width)&#13;
```&#13;
### [投射属性包装器中的值 (Projecting a Value From a Property Wrapper)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties/#Projecting-a-Value-From-a-Property-Wrapper)&#13;
🕐 在包装器中使用 `projectedValue` 可以将内部值投射到外部:访问方式为 `$` + 被包装的属性名&#13;
```swift&#13;
@propertyWrapper&#13;
struct SmallNumber {&#13;
    private var number: Int&#13;
    private(set) var projectedValue: Bool&#13;
&#13;
    var wrappedValue: Int {&#13;
        get { return number }&#13;
        set {&#13;
            if newValue &gt; 12 {&#13;
                number = 12&#13;
                projectedValue = true&#13;
            } else {&#13;
                number = newValue&#13;
                projectedValue = false&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    init() {&#13;
        self.number = 0&#13;
        self.projectedValue = false&#13;
    }&#13;
}&#13;
&#13;
struct SomeStructure {&#13;
    @SmallNumber var someNumber: Int&#13;
}&#13;
```&#13;
&#13;
🕑 访问方式为 `$` + 被包装的属性名:&#13;
```swift&#13;
var someStructure = SomeStructure()&#13;
&#13;
someStructure.someNumber = 4&#13;
print(someStructure.$someNumber) // false&#13;
&#13;
someStructure.someNumber = 55&#13;
print(someStructure.$someNumber) // true&#13;
```&#13;
## [全局和局部量 (Global and Local Variables)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties/#Global-and-Local-Variables)&#13;
&#13;
全局量总是延迟计算, 而局部量不会&#13;
## [类型属性 (Type Properties)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties/#Type-Properties)&#13;
&#13;
属于某个类型的属性, 无论该类型的实例有多少个, 都共享该属性&#13;
### [类型属性语法 (Type Property Syntax)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties/#Type-Property-Syntax)&#13;
&#13;
使用 `static` 属性:&#13;
```swift&#13;
struct SomeStructure {&#13;
    static var storedTypeProperty = 'Some value.'&#13;
    static var computedTypeProperty: Int {&#13;
        return 1&#13;
    }&#13;
}&#13;
enum SomeEnumeration {&#13;
    static var storedTypeProperty = 'Some value.'&#13;
    static var computedTypeProperty: Int {&#13;
        return 6&#13;
    }&#13;
}&#13;
class SomeClass {&#13;
    static var storedTypeProperty = 'Some value.'&#13;
    static var computedTypeProperty: Int {&#13;
        return 27&#13;
    }&#13;
    class var overrideableComputedTypeProperty: Int {&#13;
        return 107&#13;
    }&#13;
}&#13;
```&#13;
### [查询和设置类型属性 (Querying and Setting Type Properties)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties/#Querying-and-Setting-Type-Properties)&#13;
&#13;
直接通过类型访问即可:&#13;
```swift&#13;
print(SomeStructure.storedTypeProperty)&#13;
// Prints 'Some value.'&#13;
SomeStructure.storedTypeProperty = 'Another value.'&#13;
print(SomeStructure.storedTypeProperty)&#13;
// Prints 'Another value.'&#13;
print(SomeEnumeration.computedTypeProperty)&#13;
// Prints '6'&#13;
print(SomeClass.computedTypeProperty)&#13;
// Prints '27'&#13;
```&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D10%20-shu-xing.html</guid><pubDate>Wed, 24 Jul 2024 09:25:41 +0000</pubDate></item><item><title>[Swift 官方教程]09 结构体和类</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D09%20-jie-gou-ti-he-lei.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
## [对比结构体和类 (Comparing Structures and Classes)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures#Comparing-Structures-and-Classes)&#13;
---&#13;
类和结构体很像, 多数情况下结构体+枚举就够了&#13;
### [定义语法 (Definition Syntax)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures#Definition-Syntax)&#13;
&#13;
```swift&#13;
struct Resolution {&#13;
    var width = 0&#13;
    var height = 0&#13;
}&#13;
class VideoMode {&#13;
    var resolution = Resolution()&#13;
    var interlaced = false&#13;
    var frameRate = 0.0&#13;
    var name: String?&#13;
}&#13;
```&#13;
### [结构体和类实例 (Structure and Class Instances)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures#Structure-and-Class-Instances)&#13;
&#13;
```swift&#13;
let someResolution = Resolution()&#13;
let someVideoMode = VideoMode()&#13;
```&#13;
### [访问属性 (Accessing Properties)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures#Accessing-Properties)&#13;
&#13;
```swift&#13;
someResolution.width&#13;
someVideoMode.interlaced&#13;
```&#13;
### [结构体成员初始化 (Memberwise Initializers for Structure Types)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures#Memberwise-Initializers-for-Structure-Types)&#13;
&#13;
```swift&#13;
let vga = Resolution(width: 640, height: 480)&#13;
```&#13;
## [结构体和枚举是值类型 (Structures and Enumerations Are Value Types)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures#Structures-and-Enumerations-Are-Value-Types)&#13;
---&#13;
结构和枚举都是值类型&#13;
## [类是引用类型 (Classes Are Reference Types)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures#Classes-Are-Reference-Types)&#13;
&#13;
类是引用类型&#13;
### [身份运算符 (Identity Operators)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures#Identity-Operators)&#13;
&#13;
使用 `==` 鉴定两个对象是否是同一个实例&#13;
### [指针 (Pointers)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures#Pointers)&#13;
&#13;
Swift 中的引用并不是直接的实例内存地址, 即不是指针, 但是也提供了指针类型&#13;
&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D09%20-jie-gou-ti-he-lei.html</guid><pubDate>Wed, 24 Jul 2024 09:24:49 +0000</pubDate></item><item><title>[Swift 官方教程]08 枚举</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D08%20-mei-ju.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
## [枚举语法 (Enumeration Syntax)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations#Enumeration-Syntax)&#13;
---&#13;
🕐 定义: &#13;
```swift&#13;
enum CompassPoint {&#13;
    case north&#13;
    case south&#13;
    case east&#13;
    case west&#13;
}&#13;
&#13;
enum Planet {&#13;
    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune&#13;
}&#13;
```&#13;
&#13;
🕑 获取:&#13;
```swift&#13;
var d = CompassPoint.west&#13;
```&#13;
&#13;
🕒 若变量的类型已知, 则可以省略枚举类型:&#13;
```swift&#13;
d = .east&#13;
```&#13;
## [在 switch 中使用枚举值 (Matching Enumeration Values with a Switch Statement)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations#Matching-Enumeration-Values-with-a-Switch-Statement)&#13;
---&#13;
```swift&#13;
switch d {&#13;
case .north:&#13;
    print('north')&#13;
case .south:&#13;
    print('south')&#13;
case .east:&#13;
    print('east')&#13;
case .west:&#13;
    print('west')&#13;
}&#13;
```&#13;
## [遍历枚举的 case (Iterating over Enumeration Cases)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations#Iterating-over-Enumeration-Cases)&#13;
---&#13;
使用 `CaseIterable` 协议:&#13;
```swift&#13;
enum Beverage: CaseIterable {&#13;
    case coffee, tea, juice&#13;
}&#13;
```&#13;
&#13;
🕐 查看枚举数:&#13;
```swift&#13;
let n = Beverage.allCases.count&#13;
print(n)&#13;
```&#13;
&#13;
🕑 遍历:&#13;
```swift&#13;
for i in Beverage.allCases {&#13;
    print(i)&#13;
}&#13;
```&#13;
## [关联值 (Associated Values)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations#Associated-Values)&#13;
---&#13;
给枚举值设置类型: &#13;
```swift&#13;
enum Barcode {&#13;
    case upc(Int, Int, Int, Int)&#13;
    case qrCode(String)&#13;
}&#13;
```&#13;
&#13;
获取枚举值并为其设定类型值:&#13;
```swift&#13;
var code = Barcode.upc(8, 85909, 51226, 3)&#13;
code = .qrCode('ABCDEFGHIJKLMNOP')&#13;
```&#13;
&#13;
 在 `switch` 中提取枚举值的类型值:&#13;
```swift&#13;
switch code {&#13;
case .upc(let a, let b, let c, let d):&#13;
    print('UPC: \(a), \(b), \(c), \(d).')&#13;
case .qrCode(let a):&#13;
    print('QR code: \(a).')&#13;
}&#13;
```&#13;
## [原始值 (Raw Values)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations#Raw-Values)&#13;
---&#13;
给枚举添加类型, 随后设置原始值:&#13;
```swift&#13;
enum ch: Character {&#13;
    case tab = '\t'&#13;
    case lineFeed = '\n'&#13;
    case carriageReturn = '\r'&#13;
}&#13;
```&#13;
每个原始值必须是同一类型且唯一&#13;
### [隐式原始值赋值 (Implicitly Assigned Raw Values)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations#Implicitly-Assigned-Raw-Values)&#13;
&#13;
🕐 `Int` 类枚举给首个原始值赋值,  后续的原始值会自动赋值并自增:&#13;
```swift&#13;
enum Planet: Int {&#13;
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune&#13;
}&#13;
```&#13;
&#13;
🕑 `String` 类枚举的原始值为其本身转换为字符串类型:&#13;
```swift&#13;
enum CompassPoint: String { case north, south, east, west }&#13;
```&#13;
&#13;
🕒 获取原始值:&#13;
```swift&#13;
let e = Planet.earth.rawValue&#13;
let w = CompassPoint.west.rawValue&#13;
```&#13;
### [从原始值进行初始化 (Initializing from a Raw Value)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations#Initializing-from-a-Raw-Value)&#13;
&#13;
从原始值获取对应的枚举值:&#13;
```swift&#13;
let p = Planet(rawValue: 7)&#13;
```&#13;
返回的是可选值&#13;
## [递归枚举 (Recursive Enumerations)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations#Recursive-Enumerations)&#13;
---&#13;
使用 `indirect` 定义递归枚举:&#13;
```swift&#13;
enum Expression {&#13;
    case num(Int)&#13;
    indirect case add(Expression, Expression)&#13;
    indirect case multi(Expression, Expression)&#13;
}&#13;
```&#13;
可以被改写为:&#13;
```swift&#13;
indirect enum Expression {&#13;
    case num(Int)&#13;
    case add(Expression, Expression)&#13;
    case multi(Expression, Expression)&#13;
}&#13;
```&#13;
&#13;
创建对应的枚举常量:&#13;
```swift&#13;
let five = Expression.num(5)&#13;
let four = Expression.num(4)&#13;
let sum = Expression.add(five, four)&#13;
let product = Expression.multi(sum, Expression.num(2))&#13;
```&#13;
&#13;
运用它们:&#13;
```swift&#13;
func evaluate(_ e: Expression) -&gt; Int {&#13;
    switch e {&#13;
    case let .num(v):&#13;
        return v&#13;
    case let .add(left, right):&#13;
        return evaluate(left) + evaluate(right)&#13;
    case let .multi(left, right):&#13;
        return evaluate(left) * evaluate(right)&#13;
    }&#13;
}&#13;
print(evaluate(product))&#13;
```&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D08%20-mei-ju.html</guid><pubDate>Wed, 24 Jul 2024 09:23:44 +0000</pubDate></item><item><title>[Swift 官方教程]07 闭包</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D07%20-bi-bao.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
类似 lambda 表达式.&#13;
&#13;
建议: 跟着例子从上往下一步步跟着理解, 最后2小节难一点&#13;
## [闭包表达式 (Closure Expressions)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures#Closure-Expressions)&#13;
---&#13;
### [sorted 方法 (The Sorted Method)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures#The-Sorted-Method)&#13;
&#13;
根据方法对元素进行排序:&#13;
```swift&#13;
func backward(_ s1: String, _ s2: String) -&gt; Bool {&#13;
    return s1 &gt; s2&#13;
}&#13;
&#13;
let names = ['Chris', 'Alex', 'Ewa', 'Barry', 'Daniella']&#13;
var reversedNames = names.sorted(by: backward)&#13;
print(reversedNames)&#13;
```&#13;
### [闭包表达式语法 (Closure Expression Syntax)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures#Closure-Expression-Syntax)&#13;
&#13;
🕐 上述可以被改写为:&#13;
```swift&#13;
var reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in&#13;
    return s1 &gt; s2&#13;
})&#13;
&#13;
print(reversedNames)&#13;
```&#13;
即将匿名函数放在 `{}` 内,  `in` 后接函数体 &#13;
&#13;
🕑 因为函数体就一个表达式, 可以被写在一行:&#13;
```swift&#13;
var reversedNames =  names.sorted(by: { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 } )&#13;
&#13;
print(reversedNames)&#13;
```&#13;
### [从上下文中推断类型 (Inferring Type From Context)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures#Inferring-Type-From-Context)&#13;
&#13;
因为可以从上下文中推断类型, 上述可以被改写为:&#13;
```swift&#13;
var reversedNames =  names.sorted(by: { s1, s2 in return s1 &gt; s2 } )&#13;
&#13;
print(reversedNames)&#13;
```&#13;
### [单行表达式的隐式返回 (Implicit Returns from Single-Expression Closures)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures#Implicit-Returns-from-Single-Expression-Closures)&#13;
&#13;
单行表达式可省略 return:&#13;
```swift&#13;
var reversedNames =  names.sorted(by: { s1, s2 in s1 &gt; s2 } )&#13;
&#13;
print(reversedNames)&#13;
```&#13;
### [参数名简记法 (Shorthand Argument Names)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures#Shorthand-Argument-Names)&#13;
&#13;
使用 **$x** 来快速获取参数:&#13;
```swift&#13;
var reversedNames =  names.sorted(by: { $0 &gt; $1 } )&#13;
&#13;
print(reversedNames)&#13;
```&#13;
 x 的最大值+1表示该闭包所接受的参数数量&#13;
### [运算符方法 (Operator Methods)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures#Operator-Methods)&#13;
&#13;
因为 String 实现了比较操作符方法, 即接受两个 String 参数并返回布尔值, 这刚好符合要求:&#13;
```swift&#13;
var reversedNames =  names.sorted(by: &gt; )&#13;
&#13;
print(reversedNames)&#13;
```&#13;
## [尾闭包 (Trailing Closures)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures#Trailing-Closures)&#13;
---&#13;
调用闭包类型参数时, 可以将闭包写在后面:&#13;
```swift&#13;
func someFunc(closure: () -&gt; Void) {&#13;
    // function body goes here&#13;
}&#13;
```&#13;
&#13;
🕐 常规调用:&#13;
```swift&#13;
someFunc(closure: {&#13;
    // closure's body goes here&#13;
})&#13;
```&#13;
&#13;
🕑 尾调用:&#13;
```swift&#13;
someFunc() {&#13;
    // trailing closure's body goes here&#13;
}&#13;
```&#13;
### 示例 1&#13;
&#13;
🕐 例如上面的例子可改写为:&#13;
```swift&#13;
var reversedNames =  names.sorted() { $0 &gt; $1 }&#13;
&#13;
print(reversedNames)&#13;
```&#13;
&#13;
🕑 如果闭包是唯一参数, 括号可以省略:&#13;
```swift&#13;
var reversedNames =  names.sorted { $0 &gt; $1 }&#13;
&#13;
print(reversedNames)&#13;
```&#13;
### 示例 2&#13;
&#13;
下面以数组的 `map` 方法为例子:&#13;
```swift&#13;
let d = [&#13;
    0: 'Zero', 1: 'One', 2: 'Two',   3: 'Three', 4: 'Four',&#13;
    5: 'Five', 6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine'&#13;
]&#13;
let a = [16, 58, 510]&#13;
&#13;
let s = a.map { (n) -&gt; String in&#13;
    var n = n&#13;
    var output = ''&#13;
    repeat {&#13;
        output = d[n % 10]! + output&#13;
        n /= 10&#13;
    } while n &gt; 0&#13;
    return output&#13;
}&#13;
```&#13;
### 示例 3&#13;
&#13;
当有多个闭包参数时, 通过尾闭包传递第一个参数时名称可以省略, 后面的要标出:&#13;
```swift&#13;
func loadFile(from server: String, upload: (String) -&gt; Void, onFailure: () -&gt; Void) {&#13;
    print('Downloaded file from \(server)')&#13;
    if server.count &lt;= 10 {&#13;
        upload('Uploaded \(server.count) bytes.')&#13;
    } else {&#13;
        onFailure()&#13;
    }&#13;
}&#13;
```&#13;
调用:&#13;
```swift&#13;
loadFile(from: 'Youtube') { file in&#13;
    print(file)&#13;
} onFailure: {&#13;
    print('Couldn't upload the file.')&#13;
}&#13;
```&#13;
## [值获取 (Capturing Values)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures/#Capturing-Values)&#13;
&#13;
闭包可以从上下文环境中获取值:&#13;
```swift&#13;
func getIncrease(step: Int) -&gt; () -&gt; Int {&#13;
    var total = 0&#13;
    func increaser() -&gt; Int {&#13;
        total += step&#13;
        return total&#13;
    }&#13;
    return increaser&#13;
}&#13;
```&#13;
每调用一次 `f()` 返回的值都会增加:&#13;
```swift&#13;
let f = getIncrease(step: 10)&#13;
print(f())&#13;
print(f())&#13;
```&#13;
即闭包外的量与闭包绑定了&#13;
## [闭包为引用类型 (Closures Are Reference Types)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures/#Closures-Are-Reference-Types)&#13;
&#13;
即值传递类型为指针传递&#13;
## [闭包逃逸 (Escaping Closures)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures/#Escaping-Closures)&#13;
---&#13;
指的是被作为参数传递的闭包, 在函数返回后还可以被调用.&#13;
&#13;
🕐 常见的方式是将其存储到外部变量中:&#13;
```swift&#13;
var outer: [() -&gt; Void] = []&#13;
&#13;
func toOuter(c: @escaping () -&gt; Void) {&#13;
    outer.append(c)&#13;
}&#13;
```&#13;
使用 `@escaping` 定义一个可逃逸的闭包&#13;
&#13;
🕑 定义一个具有非逃逸的闭包的函数:&#13;
```swift&#13;
func noOuter(c: () -&gt; Void) {&#13;
    c()&#13;
}&#13;
```&#13;
&#13;
🕒 定义一个类调用这两个函数:&#13;
```swift&#13;
class SomeClass {&#13;
    var x = 10&#13;
    func doThing() {&#13;
        toOuter { self.x = 99 } // 等价为 { [self] in x = 99 }&#13;
        noOuter { x = 200 }&#13;
    }&#13;
}&#13;
```&#13;
对于可逃逸闭包, 需要显示指明要捕获 self, 或者将其添加到闭包的捕获列表中, 即上面的 `[self]`&#13;
&#13;
🕓 调用该类的方法:&#13;
```swift&#13;
let myClass = SomeClass()&#13;
&#13;
myClass.doThing()&#13;
print(myClass.x) // 200&#13;
```&#13;
&#13;
🕔 调用该类的逃逸闭包:&#13;
```swift&#13;
outer.first?()&#13;
print(myClass.x) // 99&#13;
```&#13;
&#13;
🕑 对于值类型则情况不同:&#13;
```swift&#13;
struct SomeStruct {&#13;
    var x = 10&#13;
    mutating func doSomething() {&#13;
        noOuter { x = 200 }  // Ok&#13;
        toOuter { x = 100 }     // Error&#13;
    }&#13;
}&#13;
```&#13;
值类型的 self 是隐式传递的, 但是逃逸闭包不能捕获值类型的 self, 因而这里将报错. &#13;
&#13;
&gt; 值类型不允许共享可变性, 也就是多个代码部分对同一数据的读写权限. 值类型被传递时将会创建一个独立的副本, 那么你修改了一个其中一个副本并不会影响到另一个副本; 因而, 假设值类型可以逃逸, 那么在逃逸闭包中对其修改后是新创建一个副本还是修改原有副本? (值类型的定义已结束)&#13;
## [自动闭包 (Autoclosures)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures#Autoclosures)&#13;
---&#13;
自动闭包用于封装一个表达式, 其返回值为表达式的执行结果&#13;
&#13;
🕐 延迟执行:&#13;
```swift&#13;
var a = ['Chris', 'Alex', 'Ewa', 'Barry', 'Daniella']&#13;
let c = { a.remove(at: 0) }&#13;
&#13;
print(a.count) // 5&#13;
print('Remove \(c())')&#13;
print(a.count) // 4&#13;
```&#13;
自动闭包中的表达式只有被调用的时候才会执行&#13;
&#13;
🕑 作为参数时的延迟执行:&#13;
```swift&#13;
func test(c: () -&gt; String) {&#13;
    print('Remove \(c())')&#13;
}&#13;
&#13;
test(c: { a.remove(at: 0) })&#13;
print(a.count) // 3&#13;
```&#13;
&#13;
🕒 可以在闭包参数前使用 `@autoclosure`, 从而在传参时省略 {}:&#13;
```swift&#13;
func test(c: @autoclosure () -&gt; String) {&#13;
    print('Remove \(c())')&#13;
}&#13;
test(c: a.remove(at: 0))&#13;
```&#13;
&#13;
🕒 可以和 `@escaping` 一起使用:&#13;
```swift&#13;
var outer: [() -&gt; String] = []&#13;
&#13;
func collect(_ c: @autoclosure @escaping () -&gt; String) {&#13;
    outer.append(c)&#13;
}&#13;
```&#13;
传递自动闭包:&#13;
```swift&#13;
collect(a.remove(at: 0))&#13;
collect(a.remove(at: 0))&#13;
print('Collected \(outer.count) closures.')&#13;
```&#13;
调用闭包:&#13;
```swift&#13;
for c in outer {&#13;
    print('Now serving \(c())')&#13;
}&#13;
```&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D07%20-bi-bao.html</guid><pubDate>Wed, 24 Jul 2024 09:22:14 +0000</pubDate></item><item><title>[Swift 官方教程]06 函数</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D06%20-han-shu.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
建议: 重点在隐式返回及其后面的部分&#13;
## [定义和调用 (Defining and Calling Functions)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Defining-and-Calling-Functions)&#13;
---&#13;
```swift&#13;
func greet(person: String) -&gt; String {&#13;
    let greeting = 'Hello, ' + person + '!'&#13;
    return greeting&#13;
}&#13;
&#13;
print(greet(person: 'root'))&#13;
```&#13;
## [参数和返回值 (Function Parameters and Return Values)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Function-Parameters-and-Return-Values)&#13;
---&#13;
### [无参 (Functions Without Parameters)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Functions-Without-Parameters)&#13;
&#13;
```swift&#13;
func greet() -&gt; String {&#13;
    return 'hello, world'&#13;
}&#13;
&#13;
print(greet())&#13;
```&#13;
### [多参 (Functions With Multiple Parameters)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Functions-With-Multiple-Parameters)&#13;
&#13;
```swift&#13;
func greet(person: String, account: Int) -&gt; String {&#13;
    return 'Hello \(person), your account is \(account).'&#13;
}&#13;
&#13;
print(greet(person: 'Tim', account: 12330))&#13;
```&#13;
### [无返回值 (Functions Without Return Values)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Functions-Without-Return-Values)&#13;
&#13;
```swift&#13;
func greet(person: String) {&#13;
    print('Hello, \(person)!')&#13;
}&#13;
&#13;
greet(person: 'Dave')&#13;
```&#13;
&#13;
实际上返回了一个类型为 `Void` 的值, 是一个空 Tuple, 即 `()`&#13;
### [多返回值 (Functions with Multiple Return Values)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Functions-with-Multiple-Return-Values)&#13;
&#13;
比如求最大最小值:&#13;
```swift&#13;
func minMax(array: [Int]) -&gt; (min: Int, max: Int) {&#13;
    var currentMin = array[0]&#13;
    var currentMax = array[0]&#13;
    for v in array[1..&lt;array.count] {&#13;
        if v &lt; currentMin {&#13;
            currentMin = v&#13;
        } else if v &gt; currentMax {&#13;
            currentMax = v&#13;
        }&#13;
    }&#13;
    return (currentMin, currentMax)&#13;
}&#13;
&#13;
let result = minMax(array: [7, 13, 28, 14, 5])&#13;
print(result.min, result.max)&#13;
```&#13;
#### [可选元组返回类型 (Optional Tuple Return Types)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Optional-Tuple-Return-Types)&#13;
&#13;
```swift&#13;
func minMax(array: [Int]) -&gt; (min: Int, max: Int)? {&#13;
    if array.isEmpty { return nil}&#13;
    &#13;
    var currentMin = array[0]&#13;
    var currentMax = array[0]&#13;
    for v in array[1..&lt;array.count] {&#13;
        if v &lt; currentMin {&#13;
            currentMin = v&#13;
        } else if v &gt; currentMax {&#13;
            currentMax = v&#13;
        }&#13;
    }&#13;
    return (currentMin, currentMax)&#13;
}&#13;
&#13;
if let result = minMax(array: [7, 13, 28, 14, 5]) {&#13;
    print(result.min, result.max)&#13;
}&#13;
```&#13;
### [隐式返回 (Functions With an Implicit Return)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Functions-With-an-Implicit-Return)&#13;
&#13;
函数仅由一个返回表达式构成, 那么可以省略 `return`:&#13;
```swift&#13;
func greet(for person: String) -&gt; String {&#13;
    'Hello, ' + person + '!'&#13;
}&#13;
&#13;
print(greet(for: 'Dave'))&#13;
```&#13;
## [形参标签和实参名称 (Function Argument Labels and Parameter Names)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Function-Argument-Labels-and-Parameter-Names)&#13;
---&#13;
默认使用形参标签作为实参名称&#13;
```swift&#13;
func greet(person: String, from hometown: String) -&gt; String {&#13;
    return 'Hello \(person)!  Glad you could visit from \(hometown).'&#13;
}&#13;
&#13;
print(greet(person: 'Bill', from: 'Cupertino'))&#13;
```&#13;
### [可忽略的形参标签 (Omitting Argument Labels)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Omitting-Argument-Labels)&#13;
&#13;
```swift&#13;
func greet(_ person: String, from hometown: String) -&gt; String {&#13;
    return 'Hello \(person)! Glad you could visit from \(hometown)'&#13;
}&#13;
&#13;
print(greet('Bill', from: 'Cupertino'))&#13;
```&#13;
### [默认参数值 (Default Parameter Values)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Default-Parameter-Values)&#13;
&#13;
```swift&#13;
func greet(person: String, from hometown: String = 'New York') -&gt; String {&#13;
    return 'Hello \(person)! Glad you could visit from \(hometown)'&#13;
}&#13;
&#13;
print(greet(person: 'Bill'))&#13;
```&#13;
### [可变参数 (Variadic Parameters)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Variadic-Parameters)&#13;
&#13;
```swift&#13;
func arithmeticMean(_ numbers: Double...) -&gt; Double {&#13;
    var total: Double = 0&#13;
    for i in numbers {&#13;
        total += i&#13;
    }&#13;
    return total / Double(numbers.count)&#13;
}&#13;
&#13;
print(arithmeticMean(3, 8.25, 18.75))&#13;
```&#13;
### [引用参数 (In-Out Parameters)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#In-Out-Parameters)&#13;
&#13;
参数默认为常量值传递, 将其设置为 `inout` 就可以引用传递:&#13;
```swift&#13;
func swapTwoInts(_ a: inout Int, _ b: inout Int) {&#13;
    let temporaryA = a&#13;
    a = b&#13;
    b = temporaryA&#13;
}&#13;
&#13;
var a = 3&#13;
var b = 107&#13;
swapTwoInts(&amp;a, &amp;b)&#13;
&#13;
print(a,b)&#13;
```&#13;
此时参数传递要加上上 `&amp;`&#13;
&#13;
&gt; inout 参数没有默认值, 可变参数不能为 inout&#13;
## [函数类型 (Function Types)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Function-Types)&#13;
---&#13;
🕐 函数可作为一种类型:&#13;
```swift&#13;
func addTwoInts(_ a: Int, _ b: Int) -&gt; Int {&#13;
    return a + b&#13;
}&#13;
```&#13;
由入参类型和出参类型组成. 例如该函数的类型为 `(Int, Int) -&gt; Int`&#13;
&#13;
🕑 该函数的类型为 `() -&gt; Void`:&#13;
```swift&#13;
func printHelloWorld() {&#13;
    print('hello, world')&#13;
}&#13;
```&#13;
### [使用函数类型 (Using Function Types)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Using-Function-Types)&#13;
&#13;
```swift&#13;
var myFunc: (Int, Int) -&gt; Int = addTwoInts&#13;
print(myFunc(1, 2))&#13;
```&#13;
### [函数类型作为参数类型 (Function Types as Parameter Types)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Function-Types-as-Parameter-Types)&#13;
&#13;
```swift&#13;
func printResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) {&#13;
    print('Result: \(mathFunction(a,b))')&#13;
}&#13;
printResult(addTwoInts, 3, 5)&#13;
```&#13;
### [参数类型作为返回类型 (Function Types as Return Types)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Function-Types-as-Return-Types)&#13;
&#13;
定义两个函数:&#13;
```swift&#13;
func add(_ input: Int) -&gt; Int {&#13;
    return input + 100&#13;
}&#13;
&#13;
func sub(_ input: Int) -&gt; Int {&#13;
    return input - 100&#13;
}&#13;
```&#13;
&#13;
使用该函数类型:&#13;
```swift&#13;
func chooseFunction(_ num: Int) -&gt; (Int) -&gt; Int {&#13;
    if num &lt; 100 {&#13;
        return add&#13;
    } else {&#13;
        return sub&#13;
    }&#13;
}&#13;
&#13;
let num = 999&#13;
let myFunc = chooseFunction(num)&#13;
print(myFunc(num))&#13;
```&#13;
## [嵌套函数 (Nested Functions)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions#Nested-Functions)&#13;
---&#13;
函数中嵌套函数:&#13;
```swift&#13;
func chooseFunction(_ num: Int) -&gt; (Int) -&gt; Int {&#13;
    func add(_ input: Int) -&gt; Int {&#13;
        return input + 100&#13;
    }&#13;
    &#13;
    func sub(_ input: Int) -&gt; Int {&#13;
        return input - 100&#13;
    }&#13;
    &#13;
    if num &lt; 100 {&#13;
        return add&#13;
    } else {&#13;
        return sub&#13;
    }&#13;
}&#13;
&#13;
let num = 999&#13;
let myFunc = chooseFunction(num)&#13;
print(myFunc(num))&#13;
```&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D06%20-han-shu.html</guid><pubDate>Wed, 24 Jul 2024 09:17:44 +0000</pubDate></item><item><title>[Swift 官方教程]05 控制流</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D05%20-kong-zhi-liu.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
建议: 重点在 Switch 及后面的部分&#13;
## [For-In 循环 (For-In Loops)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#For-In-Loops)&#13;
---&#13;
🕐 数组:&#13;
```swift&#13;
let a = [1, 2, 3, 4, 5, 6]&#13;
for i in a {&#13;
    print(i)&#13;
}&#13;
```&#13;
&#13;
🕑 字典:&#13;
```swift&#13;
let d = ['a': 18, 'b': 20, 'c': 38]&#13;
for (k, v) in d {&#13;
    print(k, v)&#13;
}&#13;
```&#13;
&#13;
🕒 区间运算:&#13;
```swift&#13;
for i in 1...5 {&#13;
    print(i)&#13;
}&#13;
&#13;
for i in 1..&lt;5 {&#13;
    print(i)&#13;
}&#13;
```&#13;
&#13;
🕓 等差列:&#13;
```swift&#13;
for i in stride(from: 0, to: 20, by: 2) { //不含 20&#13;
    print(i)&#13;
}&#13;
&#13;
for i in stride(from: 0, through: 20, by: 2) { // 含 20&#13;
    print(i)&#13;
}&#13;
```&#13;
## [While 循环 (While Loops)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#While-Loops)&#13;
---&#13;
有两种:&#13;
- `while`: 先判断再循环&#13;
- `repeat-while`: 先循环再判断&#13;
&#13;
```swift&#13;
var a = 0&#13;
let b = 10&#13;
```&#13;
### [While](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#While)&#13;
```swift&#13;
while a &lt; b {&#13;
    print(a)&#13;
    a += 1&#13;
}&#13;
```&#13;
### [Repeat-While](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#Repeat-While)&#13;
```swift&#13;
repeat {&#13;
    print(a)&#13;
    a += 1&#13;
} while a &lt; b&#13;
```&#13;
## [条件语句 (Conditional Statements)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#Conditional-Statements)&#13;
---&#13;
### [If](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#If)&#13;
```swift&#13;
let n = 95&#13;
&#13;
if n &lt; 80 {&#13;
    print('c')&#13;
} else if n &lt; 90 {&#13;
    print('b')&#13;
} else {&#13;
    print('a')&#13;
}&#13;
```&#13;
&#13;
🕐 用于赋值语句:&#13;
```swift&#13;
let n = 70&#13;
&#13;
let a: String? = if n &lt; 80 {&#13;
    'root'&#13;
} else {&#13;
    nil&#13;
}&#13;
```&#13;
&#13;
另一种等价形式 (因为用到了可选类型, 因而要提供类型信息):&#13;
```swift&#13;
let a = if n &lt; 80 {&#13;
    'root'&#13;
} else {&#13;
    nil as String?&#13;
}&#13;
```&#13;
&#13;
🕑 触发错误:&#13;
```swift&#13;
if ... {&#13;
    throw ...&#13;
} else {&#13;
}&#13;
```&#13;
### [Switch](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#Switch)&#13;
&#13;
🕐 必须要考虑所有 case, 否则要提供 default:&#13;
```swift&#13;
let ch: Character = 'z'&#13;
&#13;
switch ch {&#13;
case 'a':&#13;
    print('case 1')&#13;
case 'z':&#13;
    print('case 2')&#13;
default:&#13;
    print('default')&#13;
}&#13;
```&#13;
&#13;
🕑 多 case 组合:&#13;
```swift&#13;
let ch: Character = 'z'&#13;
&#13;
switch ch {&#13;
case 'a','A':&#13;
    print('case 1')&#13;
case 'z':&#13;
    print('case 2')&#13;
default:&#13;
    print('default')&#13;
}&#13;
```&#13;
&#13;
🕒 用于赋值:&#13;
```swift&#13;
let ch: Character = 'z'&#13;
&#13;
let s = switch ch {&#13;
case 'a':&#13;
    'case 1'&#13;
case 'z':&#13;
    'case 2'&#13;
default:&#13;
    'default'&#13;
}&#13;
```&#13;
#### 自动向下匹配 [ (No Implicit Fallthrough)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#No-Implicit-Fallthrough)&#13;
&#13;
只要匹配到 case 就停止继续向下匹配, 因而 `break` 不是必须的, 但还是可以使用&#13;
#### [区间匹配 (Interval Matching)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#Interval-Matching)&#13;
&#13;
```swift&#13;
var num = 18&#13;
&#13;
switch num {&#13;
    case 0:&#13;
        print('0')&#13;
    case 1..&lt;5:&#13;
        print('&lt;5')&#13;
    case 5..&lt;10:&#13;
        print('&lt;10')&#13;
    default:&#13;
        print('default')&#13;
}&#13;
```&#13;
#### [元组匹配 (Tuples)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#Tuples)&#13;
&#13;
```swift&#13;
let p = (1, 1)&#13;
&#13;
switch p {&#13;
case (0, 0):&#13;
    print('a')&#13;
case (_, 0):&#13;
    print('b')&#13;
case (0, _):&#13;
    print('c')&#13;
case (-2...2, -2...2):&#13;
    print('d')&#13;
default:&#13;
    print('default')&#13;
}&#13;
```&#13;
#### [值绑定 (Value Bindings)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#Value-Bindings)&#13;
&#13;
```swift&#13;
let p = (2, 0)&#13;
&#13;
switch p {&#13;
case (let x, 0):&#13;
    print(x)&#13;
case (0, let y):&#13;
    print(y)&#13;
case let (x, y):&#13;
    print(x, y)&#13;
}&#13;
```&#13;
#### [Where](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#Where)&#13;
&#13;
```swift&#13;
let p = (1, -1)&#13;
&#13;
switch p {&#13;
case let (x, y) where x == y:&#13;
    print('a')&#13;
case let (x, y) where x == -y:&#13;
    print('b')&#13;
case let (x, y):&#13;
    print(x,y)&#13;
}&#13;
```&#13;
#### [组合 case (Compound Cases)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#Compound-Cases)&#13;
&#13;
🕐 非赋值情况:&#13;
```swift&#13;
let ch: Character = 'e'&#13;
&#13;
switch ch {&#13;
case 'a', 'e', 'i', 'o', 'u':&#13;
    print('a')&#13;
case 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm',&#13;
    'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z':&#13;
    print('b')&#13;
default:&#13;
    print('default')&#13;
}&#13;
```&#13;
&#13;
🕑 赋值情况:&#13;
```swift&#13;
let p = (9, 0)&#13;
&#13;
switch p {&#13;
case (let n, 0), (0, let n):&#13;
    print(n)&#13;
default:&#13;
    print('default')&#13;
}&#13;
```&#13;
## [控制转移语句 (Control Transfer Statements)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#Control-Transfer-Statements)&#13;
---&#13;
转移控制权&#13;
### [Continue](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#Continue)&#13;
&#13;
```swift&#13;
for i in 1...5 {&#13;
    if i &lt; 3 {&#13;
        continue&#13;
    }&#13;
    print(i)&#13;
}&#13;
```&#13;
### [Break](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow/#Break)&#13;
#### [在循环中使用 (Break in a Loop Statement)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow/#Break-in-a-Loop-Statement)&#13;
&#13;
终止当前循环&#13;
#### [在 switch 中使用 break (Break in a Switch Statement)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow/#Break-in-a-Switch-Statement)&#13;
&#13;
常用来忽略某个 case 的执行&#13;
&#13;
```swift&#13;
var num = 18&#13;
&#13;
switch num {&#13;
    case 0:&#13;
        break&#13;
    case 1..&lt;5:&#13;
        print('&lt;5')&#13;
    case 5..&lt;10:&#13;
        print('&lt;10')&#13;
    default:&#13;
        break&#13;
}&#13;
```&#13;
### [自动向下匹配 (Fallthrough)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow/#Fallthrough)&#13;
&#13;
默认一旦 case 匹配就终止执行, 使用 `fallthrough` 自动向下匹配:&#13;
```swift&#13;
let num = 5&#13;
&#13;
switch num {&#13;
case 1, 3, 5:&#13;
    print('case a')&#13;
    fallthrough&#13;
case 99:&#13;
    print('case b')&#13;
default:&#13;
    print('error')&#13;
}&#13;
```&#13;
此时下一个 case 的条件将被忽略&#13;
### [带标签的语句 (Labeled Statements)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow/#Labeled-Statements)&#13;
&#13;
比如给循环语句指定标签, 从而精准控制:&#13;
```swift&#13;
let fruits = ['A', 'A', 'B', 'A', 'B', 'C', 'A']&#13;
var count = 0&#13;
&#13;
aLoop: while true {&#13;
    bLoop: for f in fruits {&#13;
        switch f {&#13;
            case 'A':&#13;
                count += 1&#13;
                print('So far, Found \(count) A ')&#13;
                continue bLoop&#13;
            case 'B':&#13;
                print('Found B')&#13;
            default:&#13;
                break&#13;
        }&#13;
        if f == 'C' {&#13;
            print('Got C, work done.')&#13;
            break aLoop&#13;
        }&#13;
    }&#13;
}&#13;
```&#13;
## [提前退出 (Early Exit)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow/#Early-Exit)&#13;
---&#13;
`guard` 中条件为真时往下执行, 否则执行 `else`, else 中必须做好控制转移:&#13;
```swift&#13;
func greet(person: [String: String]) {&#13;
    guard let name = person['name'] else {&#13;
        return&#13;
    }&#13;
&#13;
    print('Hello \(name)!') // 条件语句中的变量会保留&#13;
&#13;
    guard let location = person['location'] else {&#13;
        print('I hope the weather is nice near you.')&#13;
        return&#13;
    }&#13;
	&#13;
    print('I hope the weather is nice in \(location).')&#13;
}&#13;
&#13;
greet(person: ['name': 'John'])&#13;
greet(person: ['name': 'Jane', 'location': 'Cupertino'])&#13;
```&#13;
这里使用 `return` 提前终止函数的执行, 当然也可以用 `throw`&#13;
## [推迟行动 (Deferred Actions)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow/#Deferred-Actions)&#13;
---&#13;
在逻辑块退出之前, 按照逆序执行之前的所有被推迟的行动:&#13;
```swift&#13;
var score = 1&#13;
&#13;
if score &lt; 10 {&#13;
    defer {&#13;
        print(score)&#13;
    }&#13;
    defer {&#13;
        print('The score is:')&#13;
    }&#13;
    score += 5&#13;
}&#13;
```&#13;
实际上 `defer` 语句已经被计算了, 只是行动被推迟了&#13;
## [检查 API 可用性 (Checking API Availability)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow/#Checking-API-Availability)&#13;
---&#13;
即检查 API 的版本兼容性. 这里先了解就行, 日后用到再作深入了解&#13;
&#13;
🕐 用于条件语句:&#13;
```swift&#13;
if #available(iOS 10, macOS 10.12, *) {&#13;
    // Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS&#13;
} else {&#13;
    // Fall back to earlier iOS and macOS APIs&#13;
}&#13;
```&#13;
&#13;
🕑 用于类型:&#13;
```swift&#13;
@available(macOS 10.12, *)&#13;
struct ColorPreference {&#13;
    var bestColor = 'blue'&#13;
}&#13;
&#13;
&#13;
func chooseBestColor() -&gt; String {&#13;
    guard #available(macOS 10.12, *) else {&#13;
       return 'gray'&#13;
    }&#13;
    let colors = ColorPreference()&#13;
    return colors.bestColor&#13;
}&#13;
```&#13;
&#13;
🕒 使用 `unavailable` 判断不可用, 以下两种是等价的 &#13;
```swift&#13;
if #available(iOS 10, *) {&#13;
	...&#13;
} else {&#13;
    // Fallback code&#13;
}&#13;
```&#13;
等价于:&#13;
```swift&#13;
if #unavailable(iOS 10) {&#13;
    // Fallback code&#13;
}&#13;
```&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D05%20-kong-zhi-liu.html</guid><pubDate>Wed, 24 Jul 2024 09:15:24 +0000</pubDate></item><item><title>[Swift 官方教程]04 集合类型</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D04%20-ji-he-lei-xing.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
建议: 这部分没什么难点, 了解下各个类型的操作就行&#13;
## [集合的可变性 (Mutability of Collections)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Mutability-of-Collections)&#13;
---&#13;
是否可变取决于是 `var` 还是 `let`&#13;
## [数组 (Arrays)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Arrays)&#13;
---&#13;
同一类型值的顺序集合&#13;
### [数组类型简记法 (Array Type Shorthand Syntax)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Array-Type-Shorthand-Syntax)&#13;
&#13;
数组的完整写法为: `Array&lt;Element&gt;`, 但通常简写为: `[Element]`&#13;
### [创建空数组 (Creating an Empty Array)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Creating-an-Empty-Array)&#13;
&#13;
```swift&#13;
var a: [Int] = []&#13;
a.append(3)&#13;
a = []&#13;
```&#13;
### [创建有默认值的数组 (Creating an Array with a Default Value)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Creating-an-Array-with-a-Default-Value)&#13;
&#13;
具有 3 个相同值的数组:&#13;
```swift&#13;
var a = Array(repeating: 0.0, count: 3)&#13;
```&#13;
### [合并两个数组 (Creating an Array by Adding Two Arrays Together)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Creating-an-Array-by-Adding-Two-Arrays-Together)&#13;
&#13;
```swift&#13;
var a = Array(repeating: 0.0, count: 3)&#13;
var b = Array(repeating: 2.5, count: 4)&#13;
var c = a + b&#13;
```&#13;
### [通过数组字面量创建数组 (Creating an Array with an Array Literal)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Creating-an-Array-with-an-Array-Literal)&#13;
&#13;
```swift&#13;
var a: [String] = ['Eggs', 'Milk']&#13;
```&#13;
### [访问和修改数组 (Accessing and Modifying an Array)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Accessing-and-Modifying-an-Array)&#13;
&#13;
```swift&#13;
var a = [1, 2, 3, 4, 5]&#13;
```&#13;
&#13;
🕐 获取的元素个数:&#13;
```swift&#13;
a.count&#13;
```&#13;
&#13;
🕑 判断数组是否为空:&#13;
```swift&#13;
a.isEmpty&#13;
```&#13;
&#13;
🕒 在'数组'末尾添加元素:&#13;
```swift&#13;
a.append(6)&#13;
```&#13;
&#13;
🕓 通过索引获取和修改数组:&#13;
```swift&#13;
let e = array[0]&#13;
array[0] = 'root'&#13;
array[4...6] = ['a', 'b']&#13;
```&#13;
&#13;
🕔 插入或移除指定位置的元素:&#13;
```swift&#13;
a.insert(88, at: 0)&#13;
a.remove(at: 1)&#13;
```&#13;
&#13;
🕕 弹出最后一位元素:&#13;
```swift&#13;
let p = a.removeLast()&#13;
```&#13;
### [遍历数组 (Iterating Over an Array)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Iterating-Over-an-Array)&#13;
&#13;
🕐 遍历数组中的元素:&#13;
```swift&#13;
for v in array {&#13;
}&#13;
```&#13;
&#13;
🕑 遍历数组的索引和元素:&#13;
```swift&#13;
for (i, v) in array.enumerated() {&#13;
}&#13;
```&#13;
## [集合 (Sets)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Sets)&#13;
---&#13;
同一类型的唯一值的无序集合&#13;
### [集合的哈希值 (Hash Values for Set Types)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Hash-Values-for-Set-Types)&#13;
&#13;
集合类型必须是可哈希的, 因为要进行值比较&#13;
### [集合类型语法 (Set Type Syntax)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Set-Type-Syntax)&#13;
&#13;
集合类型写作: `Set&lt;Element&gt;`&#13;
### [创建和初始化空集合 (Creating and Initializing an Empty Set)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Creating-and-Initializing-an-Empty-Set)&#13;
&#13;
```swift&#13;
var s = Set&lt;Character&gt;()&#13;
s.insert('a')&#13;
s = []&#13;
```&#13;
### [通过数组字面量创建集合 (Creating a Set with an Array Literal)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Creating-a-Set-with-an-Array-Literal)&#13;
&#13;
```swift&#13;
var s: Set&lt;String&gt; = ['Rock', 'Classical', 'Hip hop']&#13;
```&#13;
&#13;
可以简写为:&#13;
```swift&#13;
var s: Set = ['Rock', 'Classical', 'Hip hop']&#13;
```&#13;
### [访问和修改集合 (Accessing and Modifying a Set)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Accessing-and-Modifying-a-Set)&#13;
&#13;
🕐 获取个数:&#13;
```swift&#13;
s.count&#13;
&#13;
```&#13;
&#13;
🕑 判断否为空:&#13;
```swift&#13;
s.isEmpty&#13;
```&#13;
&#13;
🕒 插入元素:&#13;
```swift&#13;
s.insert('a')&#13;
&#13;
```&#13;
&#13;
🕓 移除元素:&#13;
```swift&#13;
s.remove('a')&#13;
```&#13;
 &#13;
 🕓 是否包含某元素:&#13;
```&#13;
s.contains('a')&#13;
```&#13;
### [遍历集合 (Iterating Over a Set)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Iterating-Over-a-Set)&#13;
&#13;
🕐 遍历集合元素:&#13;
```swift&#13;
for i in s {&#13;
}&#13;
```&#13;
&#13;
🕑 排序后遍历:&#13;
```swift&#13;
for i in s.sorted() {&#13;
}&#13;
```&#13;
## [执行集合操作 (Performing Set Operations)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Performing-Set-Operations)&#13;
---&#13;
数学中的集合操作&#13;
### [基础集合操作 (Fundamental Set Operations)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Fundamental-Set-Operations)&#13;
&#13;
![[Pasted image 20240107203713.png|550]]&#13;
### [集合的成员资格和等价性 (Set Membership and Equality)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Set-Membership-and-Equality)&#13;
&#13;
```swift&#13;
let a: Set = ['🐶', '🐱']&#13;
let b: Set = ['🐮', '🐔', '🐑', '🐶', '🐱']&#13;
let c: Set = ['🐦', '🐭']&#13;
```&#13;
&#13;
🕐 判断集合是否相等:&#13;
```swift&#13;
a == b&#13;
```&#13;
&#13;
🕑 集合操作:&#13;
&#13;
```swift&#13;
a.isSubset(of: b) // 子集&#13;
a.isStrictSubset(of: b) // 严格子集&#13;
b.isSuperset(of: a) // 超集&#13;
b.isDisjoint(with: c) // 无交集&#13;
```&#13;
## [字典 (Dictionaries)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Dictionaries)&#13;
---&#13;
无序的, key 类型相同, value 类型相同&#13;
### [字典类型简记法 (Dictionary Type Shorthand Syntax)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Dictionary-Type-Shorthand-Syntax)&#13;
&#13;
字典定义为: `Dictionary&lt;Key, Value&gt;`, 可以简写为: `[Key: Value]`&#13;
### [创建空字典 (Creating an Empty Dictionary)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Creating-an-Empty-Dictionary)&#13;
&#13;
```swift&#13;
var d: [Int: String] = [:]&#13;
```&#13;
&#13;
🕐 赋值:&#13;
```swift&#13;
d[16] = 'sixteen'&#13;
```&#13;
### [通过字典字面量创建字典 (Creating a Dictionary with a Dictionary Literal)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Creating-a-Dictionary-with-a-Dictionary-Literal)&#13;
&#13;
```swift&#13;
var d: [String: Int] = ['a': 18, 'b': 28]&#13;
```&#13;
&#13;
🕐 可以简写为:&#13;
```swift&#13;
var d = ['a': 18, 'b': 28]&#13;
```&#13;
### [访问和修改字典 (Accessing and Modifying a Dictionary)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Accessing-and-Modifying-a-Dictionary)&#13;
&#13;
🕐 获取元素个数,&#13;
```swift&#13;
d.count&#13;
```&#13;
&#13;
🕑 判断是否为空:&#13;
 ```swift&#13;
d.isEmpty&#13;
```&#13;
&#13;
🕒 通过 key 添加或修改 value:&#13;
```swift&#13;
d['c'] = 19&#13;
```&#13;
&#13;
🕓 更新并返回旧 value (可选类型):&#13;
```swift&#13;
var d  = ['a': 18, 'b': 28]&#13;
if let v = d.updateValue(19, forKey: 'a') {&#13;
    print(v)&#13;
}&#13;
```&#13;
&#13;
🕔 获取 value (可选类型):&#13;
```swift&#13;
var d  = ['a': 18, 'b': 28]&#13;
if let v = d['b'] {&#13;
    print(v)&#13;
}&#13;
```&#13;
&#13;
🕕 通过赋值方式删除元素:&#13;
```swift&#13;
dict[key] = nil&#13;
```&#13;
&#13;
🕖 通过 key 删除并返回对应的 value (可选类型):&#13;
```swift&#13;
var d  = ['a': 18, 'b': 28]&#13;
if let v = d.removeValue(forKey: 'a') {&#13;
    print(v)&#13;
}&#13;
```&#13;
### [遍历字典 (Iterating Over a Dictionary)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Iterating-Over-a-Dictionary)&#13;
&#13;
🕐 遍历 key 和 value:&#13;
```swift&#13;
var d  = ['a': 18, 'b': 28]&#13;
for (k, v) in d {&#13;
}&#13;
```&#13;
&#13;
🕑 遍历 key :&#13;
```swift&#13;
for k in d.keys {&#13;
}&#13;
```&#13;
&#13;
🕒 遍历 value:&#13;
```swift&#13;
for v in d.values {&#13;
}&#13;
```&#13;
&#13;
🕓 将 key 或 value 转换为数组:&#13;
```swift&#13;
var d  = ['a': 18, 'b': 28]&#13;
let a = [String](d.keys)&#13;
let b = [Int](d.values)&#13;
```&#13;
&#13;
🕔 原地排序 key:&#13;
```swift&#13;
d.keys.sorted()&#13;
```&#13;
&#13;
🕕 原地排序 value:&#13;
```swift&#13;
d.values.sorted()&#13;
```&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D04%20-ji-he-lei-xing.html</guid><pubDate>Wed, 24 Jul 2024 09:13:10 +0000</pubDate></item><item><title>[Swift 官方教程]03 字符串和字符</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D03%20-zi-fu-chuan-he-zi-fu.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
建议: 重点理解一下字符串的底层表示, 相应部分从 **Unicode** 开始看起&#13;
## [字符串字面量 (String Literals)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#String-Literals)&#13;
---&#13;
```swift&#13;
let s = 'hello'&#13;
```&#13;
### [多行字符串字面量 (Multiline String Literals)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Multiline-String-Literals)&#13;
&#13;
🕐 多行字符串表示法, :&#13;
```swift&#13;
let s = '''&#13;
hear me now and bear witness to my vow&#13;
night gathers and now my watch begins&#13;
'''&#13;
```&#13;
&#13;
🕑 使用 `\` 在代码层面换行, 实际文字不换行:&#13;
```swift&#13;
let s = '''&#13;
hear me now and bear witness\&#13;
to my vow&#13;
night gathers and now my watch begins&#13;
'''&#13;
```&#13;
&#13;
🕒 首行缩进以末尾 `'''` 所在行的缩进为基准:&#13;
&#13;
![[Pasted image 20240107172813.png]]&#13;
### [特殊字符 (Special Characters in String Literals)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Special-Characters-in-String-Literals)&#13;
&#13;
转义字符有:&#13;
- `\0` (空字符), `\\` (反斜杠), `\t` (水平制表符), `\n` (换行), `\r` (回车), `\'` (双引号), `\'` (单引号)&#13;
- `\u{`_n_`}`, 其中 n 是 1-8 位的十六进制数, 即 Unicode 标量值&#13;
&#13;
```swift&#13;
let a = '\u{24}'        // $,  Unicode scalar U+0024&#13;
let b = '\u{2665}'      // ♥,  Unicode scalar U+2665&#13;
let c = '\u{1F496}' // 💖, Unicode scalar U+1F496&#13;
```&#13;
### [扩展的字符串界定符 (Extended String Delimiters)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Extended-String-Delimiters)&#13;
&#13;
通过在字符串外层使用 `#` (任意个数)达到在原生字符串的效果&#13;
&#13;
🕐 以下是等价的:&#13;
```swift&#13;
let s1 = #'Here are : \n'#&#13;
let s2 = ##'Here are : \n'##&#13;
let s3 = ###'Here are : \n'###&#13;
```&#13;
&#13;
🕑 在 `\` 后添加界定符以恢复特殊字符的效果:&#13;
```swift&#13;
let s1 = #'Here are : \#n'#&#13;
let s2 = ##'Here are : \##n'##&#13;
let s3 = ###'Here are : \##n'###&#13;
```&#13;
## [初始化空字符串 (Initializing an Empty String)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Initializing-an-Empty-String)&#13;
---&#13;
🕐 初始化空字符串:&#13;
```swift&#13;
var s1 = ''&#13;
var s2 = String() &#13;
```&#13;
&#13;
🕑 判断是否为空:&#13;
```swift&#13;
if s.isEmpty {&#13;
	...&#13;
}&#13;
```&#13;
## [字符串的可变性 (String Mutability)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#String-Mutability)&#13;
---&#13;
是否可变取决于是 `var` 还是 `let`&#13;
## [字符串是值类型 (Strings Are Value Types)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Strings-Are-Value-Types)&#13;
---&#13;
值类型意味着是值存储和传递, 而不是指针&#13;
## [使用字符 (Working with Characters)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Working-with-Characters)&#13;
---&#13;
🕐 字符串是字符数组:&#13;
```swift&#13;
for c in 'Dog!🐶' {&#13;
    print(c)&#13;
}&#13;
```&#13;
&#13;
🕑 定义字符:&#13;
```swift&#13;
let c: Character = '!'&#13;
```&#13;
&#13;
🕒 将字符数组转换为字符串:&#13;
```swift&#13;
let c: [Character] = ['C', 'a', 't', '!', '🐱']&#13;
let s = String(c)&#13;
```&#13;
## [拼接字符和字符串 (Concatenating Strings and Characters)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Concatenating-Strings-and-Characters)&#13;
---&#13;
🕐 拼接:&#13;
```swift&#13;
let a = 'hello'&#13;
let b = ' world'&#13;
let s = a + b&#13;
```&#13;
&#13;
🕑 复合拼接:&#13;
```swift&#13;
var s = 'hello'&#13;
s += ' world'&#13;
```&#13;
&#13;
🕒 末尾添加字符:&#13;
```swift&#13;
var s = 'hello'&#13;
s.append('!')&#13;
```&#13;
## [字符串插值 (String Interpolation)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#String-Interpolation)&#13;
---&#13;
🕐 使用 `\()` 在字符串中进行插值:&#13;
```swift&#13;
var a = 'root'&#13;
let b = 'hello \(a)'&#13;
```&#13;
&#13;
🕑 在扩展的字符串界定符中进行插值:&#13;
```swift&#13;
print(#'6 times 7 is \#(6 * 7).'#)&#13;
```&#13;
## [Unicode](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Unicode)&#13;
---&#13;
`String` 完全符合 *Unicode 标准*, 组成字符串的基本单位不再是'字符'&#13;
### [Unicode 标量值 (Unicode Scalar Values)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Unicode-Scalar-Values)&#13;
&#13;
`String` 由 *Unicode 标量值*组成&#13;
### [扩展字素簇 (Extended Grapheme Clusters)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Extended-Grapheme-Clusters)&#13;
&#13;
`Character` 表示一个单独的'扩展字素簇', 即可由多个 *Unicode 标量值*组成的序列&#13;
&#13;
🕐 如二者都表示 `é`:&#13;
```swift&#13;
let a: Character = '\u{E9}'&#13;
let b: Character = '\u{65}\u{301}' &#13;
print(a == b) // true&#13;
```&#13;
&#13;
🕑 扩展字素簇可通过组合或拆解的形式表示:&#13;
```swift&#13;
let a: Character = '\u{D55C}' // 한 &#13;
let b: Character = '\u{1112}\u{1161}\u{11AB}' // ᄒ, ᅡ, ᆫ&#13;
print(a == b) // true&#13;
```&#13;
&#13;
🕒 可以给 Unicode 标量进行字符修饰; 如给它添加某个符号:&#13;
```swift&#13;
let a: Character = '\u{E9}\u{20DD}'&#13;
```&#13;
但是其仍然被视为 `Character`&#13;
&#13;
🕔 组合地区指示符:&#13;
```swift&#13;
let a: Character = '\u{1F1FA}\u{1F1F8}'&#13;
print(a) // 🇺🇸&#13;
```&#13;
## [计算字符数量 (Counting Characters)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Counting-Characters)&#13;
---&#13;
```swift&#13;
var s = 'root'&#13;
print(s.count) // 4&#13;
```&#13;
&#13;
&gt; 计算字符数量需要遍历最底层 *Unicode 标量值*, 因而字符串越长性能也越差&#13;
## [访问和修改字符串 (Accessing and Modifying a String)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Accessing-and-Modifying-a-String)&#13;
---&#13;
### [字符串索引 (String Indices)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#String-Indices)&#13;
&#13;
每个字符串值都有其对应的索引类型 *String.Index* 来标识每个字符所在的位置, 由于字符串的特殊组成, 需要遍历 *Unicode 标量值*来决定每个字符的位置, 因而不能直接使用数值索引&#13;
&#13;
```swift&#13;
let s = 'abcdefg'&#13;
```&#13;
&#13;
🕐 获取首字符:&#13;
```swift&#13;
s[s.startIndex] // a&#13;
```&#13;
&#13;
🕑 获取指定字符前或后的字符:&#13;
```swift&#13;
s[s.index(before: s.endIndex)] // g&#13;
s[s.index(after: s.startIndex)] // b&#13;
```&#13;
其中 *endIndex* 指向最后一个字符的下一位置&#13;
&#13;
🕒 获取指定偏移位置的索引:&#13;
```swift&#13;
let index = s.index(s.startIndex, offsetBy: 3)&#13;
print(s[index]) // d&#13;
```&#13;
&#13;
🕓 通过索引遍历字符串:&#13;
```swift&#13;
for i in s.indices {&#13;
    print(s[i])&#13;
}&#13;
```&#13;
&#13;
&gt; 这种索引类型适用于任何遵循 *Collection* 协议的类型, 比如 *Array*, *Dictionary* 和 *Set*&#13;
### [插入和移除 (Inserting and Removing)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Inserting-and-Removing)&#13;
&#13;
```swift&#13;
var s = 'abcdefg'&#13;
```&#13;
&#13;
🕐 在指定索引处插入字符:&#13;
```swift&#13;
s.insert('h', at: s.endIndex)&#13;
```&#13;
&#13;
🕑 移除指定索引处的字符:&#13;
```swift&#13;
s.remove(at: s.index(before: s.endIndex))&#13;
```&#13;
&#13;
🕒 移除指定索引范围内的字符:&#13;
```swift&#13;
let range = s.index(s.endIndex, offsetBy: -2) ..&lt; s.endIndex&#13;
s.removeSubrange(range)&#13;
```&#13;
&#13;
&gt; 上述方法适用于任何遵循 *Collection* 协议的类型, 比如 *Array*, *Dictionary* 和 *Set*&#13;
## [子串 (Substrings)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Substrings)&#13;
---&#13;
子串是一个类型 `Substring`, 相当于是字符串的视图, 当你对子串进行修改时, 其会被转换为字符串&#13;
![[Pasted image 20240221154649.png|350]]&#13;
&#13;
🕐 通过索引获取子串:&#13;
```swift&#13;
var s = 'abc,def,g'&#13;
let index = s.firstIndex(of: ',') ?? s.endIndex&#13;
let a = s[..&lt;index]&#13;
```&#13;
&#13;
🕑 将字串转换为字符串:&#13;
```swift&#13;
let b = String(a)&#13;
```&#13;
## [字符串比较 (Comparing Strings)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Comparing-Strings)&#13;
---&#13;
🕐 比较字符串的值是否相等:&#13;
```swift&#13;
let a = 'I'm root'&#13;
let b = 'I'm root'&#13;
if a == b {&#13;
    print('equal')&#13;
}&#13;
```&#13;
&#13;
🕑 需要注意扩展字素簇的情况:&#13;
```swift&#13;
let a = 'Voulez-vous un caf\u{E9}?'&#13;
let b = 'Voulez-vous un caf\u{65}\u{301}?'&#13;
if a == b {&#13;
    print('equal')&#13;
}&#13;
```&#13;
因为 *\\\u{65}\\\u{301}* 为 *\\\u{E9}* 的扩展表示&#13;
### [前缀与后缀 (Prefix and Suffix Equality)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Prefix-and-Suffix-Equality)&#13;
&#13;
```swift&#13;
let list = [&#13;
    'Act 1 Scene 1: Verona, A public place',&#13;
    'Act 1 Scene 2: Capulet's mansion',&#13;
    'Act 1 Scene 3: A room in Capulet's mansion',&#13;
    'Act 1 Scene 4: A street outside Capulet's mansion',&#13;
    'Act 1 Scene 5: The Great Hall in Capulet's mansion',&#13;
    'Act 2 Scene 1: Outside Capulet's mansion',&#13;
    'Act 2 Scene 2: Capulet's orchard',&#13;
    'Act 2 Scene 3: Outside Friar Lawrence's cell',&#13;
    'Act 2 Scene 4: A street in Verona',&#13;
    'Act 2 Scene 5: Capulet's mansion',&#13;
    'Act 2 Scene 6: Friar Lawrence's cell'&#13;
]&#13;
```&#13;
&#13;
判断 `String` 是否拥有指定的前缀或后缀:&#13;
```swift&#13;
for i in list {&#13;
    if i.hasPrefix('Act 1') { // 是否拥有前缀&#13;
        print('prefix')&#13;
    }&#13;
    &#13;
    if i.hasSuffix('cell') { // 是否拥有后缀&#13;
        print('suffix')&#13;
    }&#13;
}&#13;
```&#13;
## [字符串的 Unicode 表示形式 (Unicode Representations of Strings)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Unicode-Representations-of-Strings)&#13;
---&#13;
获取 `String` 的不同表示方式&#13;
&#13;
```swift&#13;
let dogString = 'Dog‼🐶'&#13;
```&#13;
### [UTF-8 形式 (UTF-8 Representation)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#UTF-8-Representation)&#13;
![[Pasted image 20240226165335.png]]&#13;
```swift&#13;
for codeUnit in dogString.utf8 {&#13;
    print('\(codeUnit) ', terminator: '')&#13;
}&#13;
// 68 111 103 226 128 188 240 159 144 182&#13;
```&#13;
### [UTF-16 形式 (UTF-16 Representation)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#UTF-16-Representation)&#13;
![[Pasted image 20240226165345.png|550]]&#13;
```swift&#13;
for codeUnit in dogString.utf16 {&#13;
    print('\(codeUnit) ', terminator: '')&#13;
}&#13;
// 68 111 103 8252 55357 56374 &#13;
```&#13;
### [Unicode 标量值形式 (Unicode Scalar Representation)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Unicode-Scalar-Representation)&#13;
![[Pasted image 20240226165504.png|500]]&#13;
```swift&#13;
for scalar in dogString.unicodeScalars {&#13;
    print('\(scalar.value) ', terminator: '')&#13;
}&#13;
// 68 111 103 8252 128054 &#13;
```&#13;
&#13;
🕐 可以直接将该标量值转换为 `String`:&#13;
```swift&#13;
for scalar in dogString.unicodeScalars {&#13;
    print('\(scalar) ')&#13;
}&#13;
// D&#13;
// o&#13;
// g&#13;
// ‼&#13;
// 🐶&#13;
```&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D03%20-zi-fu-chuan-he-zi-fu.html</guid><pubDate>Wed, 24 Jul 2024 09:12:18 +0000</pubDate></item><item><title>[Swift 官方教程]02 基础运算符</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D02%20-ji-chu-yun-suan-fu.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
建议: 这部分理解看得懂就可以了, 不用作额外的练习&#13;
## [术语 (Terminology)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Terminology)&#13;
---&#13;
学一下英语:&#13;
- _Unary_: 一元&#13;
- _Binary_: 二元&#13;
- _Ternary_: 三元&#13;
## [算术运算符 (Arithmetic Operators)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Arithmetic-Operators)&#13;
---&#13;
🕐 加减乘除:&#13;
```swift&#13;
1 + 2&#13;
5 - 3&#13;
2 * 3&#13;
10.0 / 2.5 &#13;
```&#13;
&#13;
🕑 字符串拼接:&#13;
```swift&#13;
'hello, ' + 'world'&#13;
```&#13;
### [取余运算符 (Remainder Operator)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Remainder-Operator)&#13;
&#13;
符号跟着被除数走:&#13;
```swift&#13;
9 % 4    // 1&#13;
-9 % 4   // -1&#13;
```&#13;
### [一元负号操作符 (Unary Minus Operator)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Unary-Minus-Operator)&#13;
&#13;
```swift&#13;
let x = 3&#13;
let y = -x&#13;
let z = -y&#13;
```&#13;
### [一元正号运算符 (Unary Plus Operator)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Unary-Plus-Operator)&#13;
&#13;
```swift&#13;
let n = +3&#13;
```&#13;
&#13;
&gt; 实际不会发生任何影响&#13;
## [复合赋值运算符 (Compound Assignment Operators)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Compound-Assignment-Operators)&#13;
---&#13;
举个例子:&#13;
```swift&#13;
var n = 1&#13;
n += 2&#13;
```&#13;
## [比较运算符 (Comparison Operators)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Comparison-Operators)&#13;
---&#13;
🕐 举个例子:&#13;
```swift&#13;
1 == 1&#13;
2 != 1&#13;
2 &gt; 1&#13;
1 &lt; 2&#13;
1 &gt;= 1&#13;
2 &lt;= 1&#13;
```&#13;
&#13;
🕑 元组会逐个元素进行比较:&#13;
```swift&#13;
(1, 'a') &lt; (2, 'c')&#13;
```&#13;
## [三元条件运算符 (Ternary Conditional Operator)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Ternary-Conditional-Operator)&#13;
---&#13;
```swift&#13;
let x = 2&#13;
let b = true&#13;
let y = x + (b ? 10: 20)&#13;
```&#13;
## [空值合并运算符 (Nil-Coalescing Operator)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Nil-Coalescing-Operator)&#13;
---&#13;
即 `??`: [[01 基础部分 (The Basics)#[提供备选值 (Providing a Fallback Value)](https //docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics Providing-a-Fallback-Value)|here]]&#13;
```swift&#13;
let n = 'root'&#13;
var s: String?&#13;
let m = s ?? n&#13;
```&#13;
## [区间运算符 (Range Operators)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Range-Operators)&#13;
---&#13;
获取区间内的离散数值&#13;
### [闭区间运算符 (Closed Range Operator)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Closed-Range-Operator)&#13;
&#13;
左闭右闭:&#13;
```swift&#13;
for i in 1...5 {&#13;
    print(i)&#13;
}&#13;
```&#13;
### [半开区间运算符 (Half-Open Range Operator)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Half-Open-Range-Operator)&#13;
&#13;
左闭右开:&#13;
```swift&#13;
for i in 1..&lt;5 {&#13;
    print(i)&#13;
}&#13;
```&#13;
### [单侧区间 (One-Sided Ranges)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#One-Sided-Ranges)&#13;
&#13;
🕐 右穷尽:&#13;
```swift&#13;
let m = ['a', 'b', 'c', 'd']&#13;
for i in m[2...] {&#13;
    print(i)&#13;
}&#13;
```&#13;
&#13;
🕑 左穷尽:&#13;
```swift&#13;
let m = ['a', 'b', 'c', 'd']&#13;
for i in m[...2] {&#13;
    print(i)&#13;
}&#13;
```&#13;
&#13;
🕒 左穷尽右开:&#13;
```swift&#13;
let m = ['a', 'b', 'c', 'd']&#13;
for i in m[..&lt;2] {&#13;
    print(i)&#13;
}&#13;
```&#13;
&#13;
🕓 判断数字是否在区间中:&#13;
```swift&#13;
let range = ...5&#13;
print(range.contains(7))&#13;
```&#13;
## [逻辑运算符 (Logical Operators)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Logical-Operators)&#13;
---&#13;
### [非运算符 (Logical NOT Operator)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Logical-NOT-Operator)&#13;
&#13;
```swift&#13;
let f = false&#13;
if !f {&#13;
    print('true')&#13;
}&#13;
```&#13;
### [并且运算符 (Logical AND Operator)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Logical-AND-Operator)&#13;
&#13;
```swift&#13;
let t = true&#13;
let f = false&#13;
if t &amp;&amp; f {&#13;
    print('true')&#13;
} else {&#13;
    print('false')&#13;
}&#13;
```&#13;
### [或运算符 (Logical OR Operator)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Logical-OR-Operator)&#13;
&#13;
```swift&#13;
let t = true&#13;
let f = false&#13;
if t || f {&#13;
    print('true')&#13;
} else {&#13;
    print('false')&#13;
}&#13;
```&#13;
### [组合逻辑运算符 (Combining Logical Operators)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Combining-Logical-Operators)&#13;
&#13;
上述逻辑运算符可以组合使用&#13;
### [显式使用括号 (Explicit Parentheses)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Explicit-Parentheses)&#13;
&#13;
可以使用 `()` 改变优先级或者语法美观&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D02%20-ji-chu-yun-suan-fu.html</guid><pubDate>Wed, 24 Jul 2024 09:10:59 +0000</pubDate></item><item><title>[Swift 官方教程]01 基础部分</title><link>https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D01%20-ji-chu-bu-fen.html</link><description>[Swift官方文档同步的中文快速入门教程](https://github.com/YugenFring/swift-tutorial-quickstart/wiki)&#13;
&#13;
建议: 这部分理解看得懂就可以了, 不用作额外的练习&#13;
## [常量与变量 (Constants and Variables)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Constants-and-Variables)&#13;
---&#13;
🕐 先赋类型再赋值:&#13;
```swift&#13;
var user: String&#13;
user = 'root'&#13;
```&#13;
&#13;
🕑 赋值时自动推断类型:&#13;
```swift&#13;
let user = 'root'&#13;
var passwd = 123456&#13;
```&#13;
&#13;
&gt; 在实践中, 更多使用的是这种方式&#13;
&#13;
🕒 同时操作多个量:&#13;
```swift&#13;
var x = 0.0, y = 0.1, z = 0.2&#13;
var m, n: Double&#13;
```&#13;
## [注释 (Comments)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Comments)&#13;
---&#13;
🕐 单行注释:&#13;
```swift&#13;
// This is a comment&#13;
```&#13;
&#13;
🕑 多行注释:&#13;
```swift&#13;
/* This is also a comment&#13;
but is written over multiple lines. */&#13;
```&#13;
&#13;
🕒 多级注释 (可进行展开或折叠):&#13;
```&#13;
/* This is the start of the first multiline comment.&#13;
    /* This is the second, nested multiline comment. */&#13;
This is the end of the first multiline comment. */&#13;
```&#13;
## [分号 (Semicolons)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Semicolons)&#13;
---&#13;
不作强制要求, 但也可使用:&#13;
```swift&#13;
let name = 'root'; print(name)&#13;
```&#13;
## [整数 (Integers)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Integers)&#13;
---&#13;
一般整数使用 `Int` 即可, 如果要使用指定位数的也有&#13;
### [整数范围 (Integer Bounds)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Integer-Bounds)&#13;
&#13;
获取类型的最值:&#13;
```swift&#13;
let minValue = UInt8.min&#13;
let maxValue = UInt8.maxv&#13;
```&#13;
### [Int](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Int)&#13;
&#13;
类型 `Int` 的位数根据平台而定&#13;
### [UInt](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#UInt)&#13;
&#13;
类型 `UInt` 的位数根据平台而定&#13;
## [浮点数 (Floating-Point Numbers)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Floating-Point-Numbers)&#13;
---&#13;
- `Double` : 64-bit (至少表示 15 位小数)&#13;
- `Float` : 32-bit (差不多表示 6 位小数)&#13;
## [类型安全与类型推断 (Type Safety and Type Inference)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Type-Safety-and-Type-Inference)&#13;
---&#13;
- 类型安全: 自动检查类型是否匹配&#13;
- 类型推断: 根据值自动推断合适的类型&#13;
## [数值字面量 (Numeric Literals)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Numeric-Literals)&#13;
---&#13;
🕐 不同进制表示法:&#13;
```swift&#13;
let decimalInteger = 17&#13;
let binaryInteger = 0b10001 // 二进制&#13;
let octalInteger = 0o21 // 八进制&#13;
let hexadecimalInteger = 0x11 // 十六进制&#13;
```&#13;
&#13;
🕑 不同进制的指数表示法:&#13;
```swift&#13;
let decimalDouble = 12.1875&#13;
let exponentDouble = 1.21875e1&#13;
let hexadecimalDouble = 0xC.3p0 // 只支持十六进制&#13;
```&#13;
&#13;
🕒 填充及下划线分隔表示法:&#13;
```swift&#13;
let paddedDouble = 000123.456&#13;
let oneMillion = 1_000_000&#13;
let justOverOneMillion = 1_000_000.000_000_1&#13;
```&#13;
## [数值类型转换 (Numeric Type Conversion)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Numeric-Type-Conversion)&#13;
---&#13;
🕐 赋值不在数值类型范围内的值将会报错&#13;
&#13;
🕑 不同数值类型间不能直接操作,需显式进行类型转换:&#13;
```swift&#13;
let x: UInt16 = 2_000&#13;
let y: UInt8 = 1&#13;
let z = x + UInt16(y)&#13;
```&#13;
## [类型别名 (Type Aliases)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Type-Aliases)&#13;
---&#13;
给类型取一个别名:&#13;
```swift&#13;
typealias MyType = UInt16&#13;
var n = MyType.min&#13;
```&#13;
## [布尔值 (Booleans)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Booleans)&#13;
---&#13;
🕐 赋值:&#13;
```swift&#13;
let t = true&#13;
let f = false&#13;
```&#13;
&#13;
🕑 不是非 0 就是 true, 布尔就是布尔:&#13;
```swift&#13;
let n = 1&#13;
if n {&#13;
    // error&#13;
}&#13;
```&#13;
&#13;
&gt; 这是与其他语言较为不同的地方&#13;
## [元组 (Tuples)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Tuples)&#13;
---&#13;
🕐 元组定义与赋值:&#13;
```swift&#13;
let info = ('root', 123456)&#13;
let (user, passwd) = info&#13;
```&#13;
&#13;
🕑 赋值时使用下划线忽略:&#13;
```swift&#13;
let (user1, _) = info&#13;
```&#13;
### 索引 (Index)&#13;
&#13;
&gt; 这是比较新颖的地方, 某种程度上看起来像是 python 的字典&#13;
&#13;
🕐 通过数值索引获取元素:&#13;
```swift&#13;
print(info.0, info.1)&#13;
```&#13;
&#13;
🕑 通过名称获取元素:&#13;
```swift&#13;
let info = (user: 'root', passwd: 123456)&#13;
print(info.user, info.passwd)&#13;
```&#13;
## [可选类型 (Optionals)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Optionals)&#13;
---&#13;
🕐 定义方式: 在类型后加上 `?`&#13;
&#13;
🕑 可选类型要么有值要么为 `nil`:&#13;
```swift&#13;
var n: Int? = 404&#13;
n = nil // 可选类型可赋值 nil&#13;
```&#13;
&#13;
&gt; Swift 是非空类型的安全系统, 其要求每个量的类型都是明确的, 因此直接给量赋 `nil` 是不安全的. 推荐在可能出现 `nil` 的地方都使用可选类型, 可以把可选类型理解为一个安全的包装器&#13;
### [可选类型绑定 (Optional Binding)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Optional-Binding)&#13;
&#13;
即在条件表达式中使用赋值语句提取可选类型中的值&#13;
&#13;
🕐 当有值时, 条件表达式为 `true`, 同时提取值:&#13;
```swift&#13;
if let n = Int('123') { // 类型转换会返回可选值&#13;
    print('The number is \(n)')&#13;
} else {&#13;
    print('error')&#13;
}&#13;
```&#13;
&#13;
🕑 当条件表达式中的局部变量名与外层相同时可简写:&#13;
```swift&#13;
let n = Int('123')&#13;
if let n {&#13;
    print('My number is \(n)')&#13;
}&#13;
```&#13;
&#13;
🕒 同时进行多个可选类型绑定:&#13;
```swift&#13;
if let a = Int('4'), let b = Int('42'), a &lt; b &amp;&amp; b &lt; 100 {&#13;
    print('\(a) &lt; \(b) &lt; 100')&#13;
}&#13;
```&#13;
&#13;
&gt; 到这里可以将'可选类型绑定'理解为: 在条件语句中赋值可选类型, 就好像是使用普通类型一样&#13;
### [提供备选值 (Providing a Fallback Value)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Providing-a-Fallback-Value)&#13;
&#13;
使用 `??` 解包可选类型, 当其为 `nil` 时提供备选值:&#13;
```swift&#13;
let name: String? = nil&#13;
let greeting = 'Hello, ' + (name ?? 'root') + '!'&#13;
print(greeting)&#13;
```&#13;
### [强制解包 (Force Unwrapping)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Force-Unwrapping)&#13;
&#13;
使用 `!` 解包可选值, 若为 `nil` 将触发错误:&#13;
```swift&#13;
let s = '123s'&#13;
let i = Int(s)&#13;
let n = i!&#13;
```&#13;
### [隐式解包 (Implicitly Unwrapped Optionals)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics#Implicitly-Unwrapped-Optionals)&#13;
&#13;
适用于'当可选值有值后就一定保持有值'的情况&#13;
&#13;
🕐 定义方式: 类型后加上 `!`, 相当于可隐式解包的可选类型&#13;
&#13;
🕑 比可选类型多了自动隐式解包功能:&#13;
```swift&#13;
let user: String! = 'root'&#13;
let name: String = user&#13;
```&#13;
## [错误处理 (Error Handling)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics/#Error-Handling)&#13;
---&#13;
🕐 使用 `throws` 表明一个函数会抛出错误:&#13;
```swift&#13;
func f() throws {&#13;
	...&#13;
}&#13;
```&#13;
&#13;
🕑 处理错误的语句:&#13;
```swift&#13;
do {&#13;
	try f()&#13;
} catch {&#13;
	...&#13;
} catch {&#13;
	... &#13;
}&#13;
```&#13;
`try` 表明该函数可能会抛出错误, `catch` 用于捕获错误&#13;
## [断言和前置条件 (Assertions and Preconditions)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics/#Assertions-and-Preconditions)&#13;
---&#13;
'断言'和'前置条件'都是用于捕获意外的错误, 当不满足时中断程序执行; 前者只在开发环境中生效&#13;
&#13;
&gt; 与'错误处理'不同的是, 错误处理处理的是可预见的错误, 而这里的错误是意外的, 不可预知的, 因而不一定能够复现&#13;
### [使用断言 Debug (Debugging with Assertions)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics/#Debugging-with-Assertions)&#13;
&#13;
```swift&#13;
let n = -3&#13;
assert(n &gt;= 0, 'this is an error description') // 描述可省略&#13;
```&#13;
&#13;
手动触发断言错误:&#13;
```swift&#13;
let n = -3&#13;
if n &gt; 0 {&#13;
    assertionFailure('error')&#13;
} else {&#13;
    print('pass')&#13;
}&#13;
```&#13;
### [执行前置条件 (Enforcing Preconditions)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics/#Enforcing-Preconditions)&#13;
&#13;
```swift&#13;
let n = -3&#13;
precondition(n &gt; 0, 'this is an error descriptoin')&#13;
```&#13;
&#13;
手动触发前置条件错误:&#13;
```swift&#13;
let n = -3&#13;
if n &gt; 0 {&#13;
    preconditionFailure('error')&#13;
} else {&#13;
    print('pass')&#13;
}&#13;
```&#13;
&#13;
&gt; 关于这部分的使用还可以更进一步, 不过目前了解一下就足够了&#13;
&#13;
&#13;
&#13;
&lt;!-- ##{'script':'&lt;script src='https://blog.meekdai.com/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5BSwift%20-guan-fang-jiao-cheng-%5D01%20-ji-chu-bu-fen.html</guid><pubDate>Wed, 24 Jul 2024 08:48:30 +0000</pubDate></item><item><title>直接从Obsidian发布文章</title><link>https://cell.237927.xyz/post/zhi-jie-cong-Obsidian-fa-bu-wen-zhang.html</link><description>使用插件：[obsidian-github-issues](https://github.com/frostplexx/obsidian-github-issues)

这个插件可以在Ob中提交issues，并设置labels，这样就完美符合了Gmeek的发布文章需求。</description><guid isPermaLink="true">https://cell.237927.xyz/post/zhi-jie-cong-Obsidian-fa-bu-wen-zhang.html</guid><pubDate>Mon, 15 Jul 2024 09:02:22 +0000</pubDate></item><item><title>[转载]Swift入门教程</title><link>https://cell.237927.xyz/post/%5B-zhuan-zai-%5DSwift-ru-men-jiao-cheng.html</link><description>&gt; 原文地址 ['一篇入门swift的学习笔记' by __MrCool](https://blog.csdn.net/Void_leng/article/details/114254504#24__171)&#13;
&#13;
&lt;!-- ### 文章目录&#13;
&#13;
*   *   *   [1. 读后概述](#1)&#13;
        *   [2. 语法笔记](#2)&#13;
        *   *   [2.1 说明](#2.1)&#13;
            *   [2.2 基础类型](#2.2)&#13;
            *   [2.3 运算符](#2.3)&#13;
            *   [2.4 字符与字符串](#2.4)&#13;
            *   [2.5 控制流](#2.5)&#13;
            *   [2.6 函数](#2.6)&#13;
            *   [2.7 闭包](#2.7)&#13;
            *   [2.8 枚举、结构体、类](#2.8)&#13;
            *   [2.9 类的构造与析构](#2.9)&#13;
            *   [2.10 属性监听器](#2.10)&#13;
            *   [2.11 类的继承](#2.11)&#13;
            *   [2.12 扩展](#2.12)&#13;
            *   [2.13 协议](#2.13)&#13;
            *   [2.14 泛型](#2.14)&#13;
        *   [3. 总结](#3)&#13;
--&gt;&#13;
&lt;a a='1'&gt;&lt;/span&gt;&#13;
## 1. 读后概述&#13;
&#13;
阅读完[《the swift programming language 中文版》](https://swiftgg.gitbook.io/swift/)，对 swift 语言有了初步的认识。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%5B-zhuan-zai-%5DSwift-ru-men-jiao-cheng.html</guid><pubDate>Sat, 13 Jul 2024 14:35:31 +0000</pubDate></item><item><title>【肖申克的救赎】Andy留给Red的信</title><link>https://cell.237927.xyz/post/%E3%80%90-xiao-shen-ke-de-jiu-shu-%E3%80%91Andy-liu-gei-Red-de-xin.html</link><description>Dear Red,&#13;
&#13;
If you're reading this, you've gotten out. And if you've come this far, maybe you're willing to come a little further. You remember the name of the town, don't you? I could use a good man to help me get my project on wheels. I'll keep an eye out for you and the chessboard ready.&#13;
&#13;
Remember, Red. Hope is a good thing, maybe the best of things, and no good thing ever dies. I will be hoping that this letter finds you, and finds you well.&#13;
&#13;
Your friend,&#13;
Andy&#13;
&#13;
&#13;
&gt;亲爱的瑞德，&#13;
&gt;&#13;
&gt;如果你正在读这封信，那你已经出来了。</description><guid isPermaLink="true">https://cell.237927.xyz/post/%E3%80%90-xiao-shen-ke-de-jiu-shu-%E3%80%91Andy-liu-gei-Red-de-xin.html</guid><pubDate>Fri, 05 Jul 2024 16:33:53 +0000</pubDate></item><item><title>影视站点合集</title><link>https://cell.237927.xyz/post/ying-shi-zhan-dian-he-ji.html</link><description>---&#13;
## **云盘搜索**&#13;
https://www.yunpan1.cc/&#13;
https://pan666.net/&#13;
https://www.wpzysq.com/&#13;
&#13;
---&#13;
## **影视合集**&#13;
[电视剧.韩剧.韩语中字](https://www.aliyundrive.com/s/JHpBvN6QUac)&#13;
[合集贴](https://slowread.net/ali110.html)&#13;
&#13;
---&#13;
&#13;
&#13;
。</description><guid isPermaLink="true">https://cell.237927.xyz/post/ying-shi-zhan-dian-he-ji.html</guid><pubDate>Sun, 07 Apr 2024 08:14:05 +0000</pubDate></item><item><title>简易的小站</title><link>https://cell.237927.xyz/post/jian-yi-de-xiao-zhan.html</link><description>在这里记录下今后的日子，过去的已经过去，希望会带着我走向明天。</description><guid isPermaLink="true">https://cell.237927.xyz/post/jian-yi-de-xiao-zhan.html</guid><pubDate>Sun, 07 Apr 2024 07:23:26 +0000</pubDate></item><item><title>关于本站</title><link>https://cell.237927.xyz/about.html</link><description>237号房间的故事。</description><guid isPermaLink="true">https://cell.237927.xyz/about.html</guid><pubDate>Sat, 06 Jul 2024 05:58:55 +0000</pubDate></item><item><title>友情链接</title><link>https://cell.237927.xyz/link.html</link><description>本页记录收录的各种实用或有趣的网页。</description><guid isPermaLink="true">https://cell.237927.xyz/link.html</guid><pubDate>Thu, 25 Jul 2024 13:55:51 +0000</pubDate></item></channel></rss>